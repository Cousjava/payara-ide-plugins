<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<!-- GenHTML revision 23224-->
<meta http-equiv="Content-type" content="text/html; charset=utf-8">
<title>Securing Applications - Sun GlassFish Enterprise Server v3 Application Development Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2009-11-01">
</head>

<body>


<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&#160;</td>
<td><a href="p9.html">Previous</a></td>
<td></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p11.html">Next</a></td>
</tr>
</table>


<a name="beabg"></a>Chapter&#160;5<h3>Securing Applications</h3><a name="indexterm-229"></a><p>This chapter describes how to write secure Java EE applications, which contain components
that perform user authentication and access authorization for the business logic of Java
EE components. </p><p>For information about administrative security for the Enterprise Server, see <a href="http://docs.sun.com/doc/820-7692/ablnk?a=view">Chapter 11, Administering System Security, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a>.</p><p>For general information about Java EE security, see <a href="http://docs.sun.com/doc/820-7627/gijrp?a=view">Part&#160;VI, Security, in <i>The Java EE 6 Tutorial, Volume I</i></a>.</p><p>This chapter contains the following sections:</p>
<ul><li><p><a href="#beabh">Security Goals</a></p></li>
<li><p><a href="#beabi">Enterprise Server Specific Security Features</a></p></li>
<li><p><a href="#beabj">Container Security</a></p></li>
<li><p><a href="#beacr">Roles, Principals, and Principal to Role Mapping</a></p></li>
<li><p><a href="#beabo">Realm Configuration</a></p></li>
<li><p><a href="#beabt">JACC Support</a></p></li>
<li><p><a href="#beabu">Pluggable Audit Module Support</a></p></li>
<li><p><a href="#beabx">The <tt>server.policy</tt> File</a></p></li>
<li><p><a href="#beaca">Configuring Message Security for Web Services</a></p></li>
<li><p><a href="#beacm">Programmatic Login</a></p></li>
<li><p><a href="#beacq">User Authentication for Single Sign-on</a></p></li>
<li><p><a href="#gizel">Adding Authentication Mechanisms to the Servlet Container</a></p></li></ul>

<hr><p><b>Note - </b>The Web Profile of the Enterprise Server supports the EJB 3.1 Lite specification,
which allows enterprise beans within web applications, among other features. The full Enterprise
Server supports the entire EJB 3.1 specification. For details, see <a href="http://jcp.org/en/jsr/detail?id=318">JSR 318</a>.</p>
<hr>


<a name="beabh"></a><h3>Security Goals</h3>
<a name="indexterm-230"></a><p>In an enterprise computing environment, there are many security risks. The goal of
the Sun GlassFish Enterprise Server is to provide highly secure, interoperable, and distributed
component computing based on the Java EE security model. Security goals include:</p>
<ul><li><p>Full compliance with the Java EE security model. This includes EJB and servlet role-based authorization.</p></li>
<li><p>Support for single sign-on across all Enterprise Server applications within a single security domain.</p></li>
<li><p>Support for web services message security.</p></li>
<li><p>Security support for application clients.</p></li>
<li><p>Support for several underlying authentication realms, such as simple file and Lightweight Directory Access Protocol (LDAP). Certificate authentication is also supported for Secure Socket Layer (SSL) client authentication. For Solaris, OS platform authentication is supported in addition to these.</p></li>
<li><p>Support for declarative security through Enterprise Server specific XML-based role mapping.</p></li>
<li><p><a name="indexterm-231"></a>Support for Java Authorization Contract for Containers (JACC) pluggable authorization as included in the Java EE specification and defined by <a href="http://www.jcp.org/en/jsr/detail?id=115">Java Specification Request (JSR) 115</a>.</p></li>
<li><p><a name="indexterm-232"></a>Support for Java<sup>TM</sup> Authentication Service Provider Interface for Containers as included in the Java EE specification and defined by <a href="http://www.jcp.org/en/jsr/detail?id=196">JSR 196</a>.</p></li>
<li><p><a name="indexterm-233"></a>Support for Web Services Interoperability Technologies (WSIT) as described in <a href="https://metro.dev.java.net/guide/">Metro Users Guide</a>.</p></li></ul>


<a name="beabi"></a><h3>Enterprise Server Specific Security Features</h3>
<a name="indexterm-234"></a><a name="indexterm-235"></a><a name="indexterm-236"></a><p>The Enterprise Server supports the Java EE security model, as well as the
following features which are specific to the Enterprise Server:</p>
<ul><li><p>Message security; see <a href="#beaca">Configuring Message Security for Web Services</a></p></li>
<li><p>Single sign-on across all Enterprise Server applications within a single security domain; see <a href="#beacq">User Authentication for Single Sign-on</a></p></li>
<li><p>Programmatic login; see <a href="#beacm">Programmatic Login</a></p></li></ul>


<a name="beabj"></a><h3>Container Security</h3>
<a name="indexterm-237"></a><p>The component containers are responsible for providing Java EE application security. The container
provides two security forms:</p>
<ul><li><p><a href="#beabl">Declarative Security</a></p></li>
<li><p><a href="#beabk">Programmatic Security</a></p></li></ul>
<p><a name="indexterm-238"></a><a name="indexterm-239"></a><b>Annotations</b> (also called metadata) enable a declarative style of programming, and so encompass
both the declarative and programmatic security concepts. Users can specify information about security within
a class file using annotations. When the application is deployed, this information can
either be used by or overridden by the application or module deployment descriptor.</p>

<a name="beabl"></a><h4>Declarative Security</h4>
<p><a name="indexterm-240"></a><b>Declarative security</b> means that the security mechanism for an application is declared and handled
externally to the application. Deployment descriptors describe the Java EE application&#8217;s security structure, including
security roles, access control, and authentication requirements.</p><p>The Enterprise Server supports the deployment descriptors specified by Java EE and has
additional security elements included in its own deployment descriptors. Declarative security is the
application deployer&#8217;s responsibility. For more information about Sun-specific deployment descriptors, see the <a href="http://docs.sun.com/doc/820-7693"><i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p><p>There are two levels of declarative security, as follows:</p>
<ul><li><p><a href="#beabm">Application Level Security</a></p></li>
<li><p><a href="#beabn">Component Level Security</a></p></li></ul>


<a name="beabm"></a><h5>Application Level Security</h5>
<a name="indexterm-241"></a><p>For an application, roles used by any application must be defined in <tt>@DeclareRoles</tt>
annotations in the code or <tt>role-name</tt> elements in the application deployment descriptor
(<tt>application.xml</tt>). Those role names are scoped to the EJB XML deployment descriptors (<tt>ejb-jar.xml</tt>
and <tt>sun-ejb-jar.xml</tt> files) and to the servlet XML deployment descriptors (<tt>web.xml</tt> and <tt>sun-web.xml</tt>
files). For an individually deployed web or EJB module, you define roles using
<tt>@DeclareRoles</tt> annotations or <tt>role-name</tt> elements in the Java EE deployment descriptor files <tt>web.xml</tt> or
<tt>ejb-jar.xml</tt>.</p><p>To map roles to principals and groups, define matching <tt>security-role-mapping</tt> elements in
the <tt>sun-application.xml</tt>, <tt>sun-ejb-jar.xml</tt>, or <tt>sun-web.xml</tt> file for each <tt>role-name</tt> used by the application.
For more information, see <a href="#beacr">Roles, Principals, and Principal to Role Mapping</a>.</p>

<a name="beabn"></a><h5>Component Level Security</h5>
<a name="indexterm-242"></a><a name="indexterm-243"></a><p>Component level security encompasses web components and EJB components.</p><p>A secure web container authenticates users and authorizes access to a servlet or
JSP by using the security policy laid out in the servlet XML deployment
descriptors (<tt>web.xml</tt> and <tt>sun-web.xml</tt> files).</p><p><a name="indexterm-244"></a><a name="indexterm-245"></a>The EJB container is responsible for authorizing access to a bean method by
using the security policy laid out in the EJB XML deployment descriptors (<tt>ejb-jar.xml</tt>
and <tt>sun-ejb-jar.xml</tt> files).</p>

<a name="beabk"></a><h4>Programmatic Security</h4>
<p><a name="indexterm-246"></a><b>Programmatic security</b> involves an EJB component or servlet using method calls to the security
API, as specified by the Java EE security model, to make business logic
decisions based on the caller or remote user&#8217;s security role. Programmatic security should only
be used when declarative security alone is insufficient to meet the application&#8217;s security
model.</p><p><a name="indexterm-247"></a>The Java EE specification defines programmatic security as consisting of two methods of
the EJB <tt>EJBContext</tt> interface and two methods of the servlet <tt>HttpServletRequest</tt> interface.
The Enterprise Server supports these interfaces as specified in the specification.</p><p>For more information on programmatic security, see the following:</p>
<ul><li><p>The Java EE Specification</p></li>
<li><p><a href="#beacm">Programmatic Login</a></p></li></ul>


<a name="beacr"></a><h3>Roles, Principals, and Principal to Role Mapping</h3>
<a name="indexterm-248"></a><a name="indexterm-249"></a><a name="indexterm-250"></a><a name="indexterm-251"></a><p>For applications, you define roles in <tt>@DeclareRoles</tt> annotations or the Java EE deployment
descriptor file <tt>application.xml</tt>. You define the corresponding role mappings in the Enterprise Server
deployment descriptor file <tt>sun-application.xml</tt>. For individually deployed web or EJB modules, you define roles
in <tt>@DeclareRoles</tt> annotations or the Java EE deployment descriptor files <tt>web.xml</tt> or <tt>ejb-jar.xml</tt>.
You define the corresponding role mappings in the Enterprise Server deployment descriptor files
<tt>sun-web.xml</tt> or <tt>sun-ejb-jar.xml</tt>.</p><p>For more information regarding Java EE deployment descriptors, see the Java EE Specification.
For more information regarding Enterprise Server deployment descriptors, see <a href="http://docs.sun.com/doc/820-7693/beaqi?a=view">Appendix C, <i>Elements of the Enterprise Server Deployment Descriptors,</i> in <i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p><p>Each <tt>security-role-mapping</tt> element in the <tt>sun-application.xml</tt>, <tt>sun-web.xml</tt>, or <tt>sun-ejb-jar.xml</tt> file maps a
role name permitted by the application or module to principals and groups. For
example, a <tt>sun-web.xml</tt> file for an individually deployed web module might contain the
following:</p><pre>&#60;sun-web-app>
    &#60;security-role-mapping>
        &#60;role-name>manager&#60;/role-name>
        &#60;principal-name>jgarcia&#60;/principal-name>
        &#60;principal-name>mwebster&#60;/principal-name>
        &#60;group-name>team-leads&#60;/group-name>
    &#60;/security-role-mapping>
    &#60;security-role-mapping>
        &#60;role-name>administrator&#60;/role-name>
        &#60;principal-name>dsmith&#60;/principal-name>
    &#60;/security-role-mapping>
&#60;/sun-web-app></pre><p>A role can be mapped to either specific principals or to groups (or
both). The principal or group names used must be valid principals or groups
in the realm for the application or module. Note that the <tt>role-name</tt>
in this example must match the <tt>@DeclareRoles</tt> annotations or the <tt>role-name</tt> in
the <tt>security-role</tt> element of the corresponding <tt>web.xml</tt> file.</p><p>You can also specify a custom principal implementation class. This provides more flexibility
in how principals can be assigned to roles. A user's JAAS login module
now can authenticate its custom principal, and the authenticated custom principal can further
participate in the Enterprise Server authorization process. For example:</p><pre>&#60;security-role-mapping>
    &#60;role-name>administrator&#60;/role-name>
    &#60;principal-name class-name="CustomPrincipalImplClass">
        dsmith
    &#60;/principal-name>
&#60;/security-role-mapping></pre><p>You can specify a default principal and a default principal to role mapping,
each of which applies to the entire Enterprise Server. The default principal to
role mapping maps group principals to the same named roles. Web modules that
omit the <tt>run-as</tt> element in <tt>web.xml</tt> use the default principal. Applications and
modules that omit the <tt>security-role-mapping</tt> element use the default principal to role mapping. These
defaults are part of the Security Service, which you can access in the
following ways:</p>
<ul><li><p><a name="indexterm-252"></a>In the Administration Console, select the Security component under the relevant configuration. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-253"></a><a name="indexterm-254"></a>Use the <tt>asadmin set</tt> command. For details, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>. For example, you can set the default principal as follows.</p><pre>asadmin set server-config.security-service.default-principal=dsmith
asadmin set server-config.security-service.default-principal-password=secret</pre><p>You can set the default principal to role mapping as follows.</p><pre>asadmin set server-config.security-service.activate-default-principal-to-role-mapping=true
asadmin set server-config.security-service.mapped-principal-class=CustomPrincipalImplClass</pre></li></ul>


<a name="beabo"></a><h3>Realm Configuration</h3>
<p>This section covers the following topics:</p>
<ul><li><p><a href="#beabp">Supported Realms</a></p></li>
<li><p><a href="#beabq">How to Configure a Realm</a></p></li>
<li><p><a href="#beabr">How to Set a Realm for an Application or Module</a></p></li>
<li><p><a href="#beabs">Creating a Custom Realm</a></p></li></ul>


<a name="beabp"></a><h4>Supported Realms</h4>
<a name="indexterm-255"></a><a name="indexterm-256"></a><p>The following realms are supported in the current release of the Enterprise Server:</p>
<ul><li><p><a name="indexterm-257"></a><tt>file</tt> &#8211; Stores user information in a file. This is the default realm when you first install the Enterprise Server.</p></li>
<li><p><a name="indexterm-258"></a><tt>ldap</tt> &#8211; Stores user information in an LDAP directory.</p></li>
<li><p><a name="indexterm-259"></a><a name="indexterm-260"></a><tt>jdbc</tt> &#8211; Stores user information in a database.</p><p>In the JDBC realm, the server gets user credentials from a database. The Enterprise Server uses the database information and the enabled JDBC realm option in the configuration file. For digest authentication, a JDBC realm should be created with <tt>jdbcDigestRealm</tt> as the JAAS context.</p></li>
<li><p><a name="indexterm-261"></a><tt>certificate</tt> &#8211; Sets up the user identity in the Enterprise Server security context, and populates it with user data obtained from cryptographically verified client certificates.</p></li>
<li><p><a name="indexterm-262"></a><tt>solaris</tt> &#8211; Allows authentication using Solaris <tt>username+password</tt> data. This realm is only supported on the Solaris operating system, version 9 and above.</p></li></ul>
<p>For information about configuring realms, see <a href="#beabq">How to Configure a Realm</a>.</p>

<a name="beabq"></a><h4>How to Configure a Realm</h4>
<a name="indexterm-263"></a><p>You can configure a realm in one of these ways:</p>
<ul><li><p><a name="indexterm-264"></a>In the Administration Console, open the Security component under the relevant configuration and go to the Realms page. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-265"></a><a name="indexterm-266"></a>Use the <tt>asadmin create-auth-realm</tt> command to configure realms on local servers. For details, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p></li></ul>


<a name="beabr"></a><h4>How to Set a Realm for an Application or Module</h4>
<p><a name="indexterm-267"></a>The following deployment descriptor elements have optional <tt>realm</tt> or <tt>realm-name</tt> data subelements or attributes
that override the domain&#8217;s default realm:</p>
<ul><li><p><tt>sun-application</tt> element in <tt>sun-application.xml</tt></p></li>
<li><p><tt>web-app</tt> element in <tt>web.xml</tt></p></li>
<li><p><tt>as-context</tt> element in <tt>sun-ejb-jar.xml</tt></p></li>
<li><p><tt>client-container</tt> element in <tt>sun-acc.xml</tt></p></li>
<li><p><tt>client-credential</tt> element in <tt>sun-acc.xml</tt></p></li></ul>
<p>If modules within an application specify realms, these are ignored. If present, the
realm defined in <tt>sun-application.xml</tt> is used, otherwise the domain&#8217;s default realm is used.</p><p>For example, a realm is specified in <tt>sun-application.xml</tt> as follows:</p><pre>&#60;sun-application>
    ...
    &#60;realm>ldap&#60;/realm>
&#60;/sun-application></pre><p>For more information about the deployment descriptor files and elements, see <a href="http://docs.sun.com/doc/820-7693/beaqi?a=view">Appendix C, <i>Elements of the Enterprise Server Deployment Descriptors,</i> in <i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p>

<a name="beabs"></a><h4>Creating a Custom Realm</h4>
<a name="indexterm-268"></a><a name="indexterm-269"></a><a name="indexterm-270"></a><a name="indexterm-271"></a><p>You can create a custom realm by providing a custom Java Authentication and
Authorization Service (JAAS) login module class and a custom realm class. Note that
client-side JAAS login modules are not suitable for use with the Enterprise Server.
</p><p>To activate the custom login modules and realms, place the JAR files in
the <i>domain-dir</i><tt>/lib</tt> directory or the class files in the <i>domain-dir</i><tt>/lib/classes</tt> directory. For more
information about class loading in the Enterprise Server, see <a href="p6.html">Chapter&#160;2, Class Loaders</a>.</p><p><a name="indexterm-272"></a>JAAS is a set of APIs that enable services to authenticate and enforce
access controls upon users. JAAS provides a pluggable and extensible framework for programmatic
user authentication and authorization. JAAS is a core API and an underlying technology
for Java EE security mechanisms. For more information about JAAS, refer to the JAAS
specification for Java SDK, available at <a href="http://java.sun.com/products/jaas/">http://java.sun.com/products/jaas/</a>.</p><p>For general information about realms and login modules, see <a href="http://docs.sun.com/doc/820-7627/bnbxj?a=view">Working with Realms, Users, Groups, and Roles in <i>The Java EE 6 Tutorial, Volume I</i></a>.</p><p>For Javadoc tool pages relevant to custom realms, go to <a href="http://java.sun.com/javaee/6/docs/api/">http://java.sun.com/javaee/6/docs/api/</a> and click
on the <tt>com.sun.appserv.security</tt> package.</p><p><a name="indexterm-273"></a><a name="indexterm-274"></a>Custom login modules must extend the <tt>com.sun.appserv.security.AppservPasswordLoginModule</tt> class. This class implements <tt>javax.security.auth.spi.LoginModule</tt>. Custom
login modules must not implement <tt>LoginModule</tt> directly.</p><p>Custom login modules must provide an implementation for one abstract method defined in
<tt>AppservPasswordLoginModule</tt>:</p><pre>abstract protected void authenticateUser() throws LoginException</pre><p>This method performs the actual authentication. The custom login module must not implement
any of the other methods, such as <tt>login()</tt>, <tt>logout()</tt>, <tt>abort()</tt>, <tt>commit()</tt>, or
<tt>initialize()</tt>. Default implementations are provided in <tt>AppservPasswordLoginModule</tt> which hook into the Enterprise Server infrastructure.</p><p>The custom login module can access the following protected object fields, which it
inherits from <tt>AppservPasswordLoginModule</tt>. These contain the user name and password of the user
to be authenticated:</p><pre>protected String _username;
protected String _password;</pre><p>The <tt>authenticateUser()</tt> method must end with the following sequence:</p><pre>String[] grpList;
// populate grpList with the set of groups to which
// _username belongs in this realm, if any
commitUserAuthentication(_username, _password, 
  _currentRealm, grpList);</pre><p><a name="indexterm-275"></a>Custom realms must extend the <tt>com.sun.appserv.security.AppservRealm</tt> class and implement the following methods:</p><pre>public void init(Properties props) throws BadRealmException, 
    NoSuchRealmException</pre><p>This method is invoked during server startup when the realm is initially loaded.
The <tt>props</tt> argument contains the properties defined for this realm. The realm can
do any initialization it needs in this method. If the method returns without
throwing an exception, the Enterprise Server assumes that the realm is ready to
service authentication requests. If an exception is thrown, the realm is disabled.</p><pre>public String getAuthType()</pre><p>This method returns a descriptive string representing the type of authentication done by
this realm.</p><pre>public abstract Enumeration getGroupNames(String username) throws 
    InvalidOperationException, NoSuchUserException</pre><p>This method returns an <tt>Enumeration</tt> (of <tt>String</tt> objects) enumerating the groups (if
any) to which the given <tt>username</tt> belongs in this realm.</p><p>Custom realms that manage users must implement the following additional methods:</p><pre>public abstract boolean supportsUserManagement();</pre><p>This method returns <tt>true</tt> if the realm supports user management.</p><pre>public abstract Enumeration getGroupNames() throws BadRealmException;</pre><p>This method returns an <tt>Enumeration</tt> of all group names.</p><pre>public abstract Enumeration getUserNames() throws BadRealmException;</pre><p>This method returns an <tt>Enumeration</tt> of all user names.</p><pre>public abstract void refresh() throws BadRealmException;</pre><p>This method refreshes the realm data so that new users and groups are
visible.</p><pre>public abstract void persist() throws BadRealmException;</pre><p>This method persists the realm data to permanent storage.</p><pre>public abstract User getUser(String name) throws NoSuchUserException, 
BadRealmException;</pre><p>This method returns the information recorded about a particular named user.</p><pre>public abstract void addUser(String name, String password, String[] groupList) throws 
BadRealmException, IASSecurityException;</pre><p>This method adds a new user, who cannot already exist.</p><pre>public abstract void removeUser(String name) throws NoSuchUserException, 
BadRealmException;</pre><p>This method removes a user, who must exist.</p><pre>public abstract void updateUser(String name, String newName, String password, 
String[] groups) throws NoSuchUserException, BadRealmException, IASSecurityException;</pre><p>This method updates data for a user, who must exist.</p>
<hr><p><b>Note - </b>The array passed to the <tt>commitUseAuthentication</tt> method should be newly created and otherwise
unreferenced. This is because the group name array elements are set to null
after authentication as part of cleanup. So the second time your custom realm
executes it returns an array with null elements.</p><p>Ideally, your custom realm should not return member variables from the <tt>authenticate</tt> method.
It should return local variables as the default <tt>JDBCRealm</tt> does. Your custom
realm can create a local <tt>String</tt> array in its <tt>authenticate</tt> method, copy the
values from the member variables, and return the <tt>String</tt> array. Or it can
use <tt>clone</tt> on the member variables.</p>
<hr>


<a name="beabt"></a><h3>JACC Support</h3>
<p><a name="indexterm-276"></a><a name="indexterm-277"></a><a name="indexterm-278"></a><a name="indexterm-279"></a><a name="indexterm-280"></a>JACC (Java Authorization Contract for Containers) is part of the Java EE specification and
defined by <a href="http://www.jcp.org/en/jsr/detail?id=115">JSR 115</a>. JACC defines an interface for pluggable authorization providers. Specifically, JACC
is used to plug in the Java policy provider used by the container
to perform Java EE caller access decisions. The Java policy provider performs Java
policy decisions during application execution. This provides third parties with a mechanism to
develop and plug in modules that are responsible for answering authorization decisions during Java
EE application execution. The interfaces and rules used for developing JACC providers are
defined in the JACC 1.0 specification.</p><p><a name="indexterm-281"></a>The Enterprise Server provides a simple file-based JACC-compliant authorization engine as a default
JACC provider, named <tt>default</tt>. An alternate provider named <tt>simple</tt> is also provided. To
configure an alternate provider using the Administration Console, open the Security component under
the relevant configuration, and select the JACC Providers component. For details, click the
Help button in the Administration Console.</p>

<a name="beabu"></a><h3>Pluggable Audit Module Support</h3>
<a name="indexterm-282"></a><a name="indexterm-283"></a><p>Audit modules collect and store information on incoming requests (servlets, EJB components) and
outgoing responses. You can create a custom audit module. This section covers the
following topics:</p>
<ul><li><p><a href="#beabv">Configuring an Audit Module</a></p></li>
<li><p><a href="#beabw">The <tt>AuditModule</tt> Class</a></p></li></ul>
<p>For additional information about audit modules, see <a href="http://developers.sun.com/prodtech/appserver/reference/techart/ws_mgmt3.html#8.2">Audit Callbacks</a>.</p>

<a name="beabv"></a><h4>Configuring an Audit Module</h4>
<p>To configure an audit module, you can perform one of the following tasks:</p>
<ul><li><p><a name="indexterm-284"></a>To specify an audit module using the Administration Console, open the Security component under the relevant configuration, and select the Audit Modules component. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-285"></a><a name="indexterm-286"></a>You can use the <tt></tt><tt>asadmin create-audit-module</tt> command to configure an audit module. For details, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p></li></ul>


<a name="beabw"></a><h4>The <tt>AuditModule</tt> Class</h4>
<a name="indexterm-287"></a><p>You can create a custom audit module by implementing a class that extends
<tt>com.sun.appserv.security.audit.AuditModule</tt>. </p><p>For Javadoc tool pages relevant to audit modules, go to <a href="http://java.sun.com/javaee/6/docs/api/">http://java.sun.com/javaee/6/docs/api/</a> and click
on the <tt>com.sun.appserv.security.audit</tt> package.</p><p>The <tt>AuditModule</tt> class provides default &#8220;no-op&#8221; implementations for each of the following methods,
which your custom class can override.</p><pre>public void init(Properties props)</pre><p>The preceding method is invoked during server startup when the audit module is
initially loaded. The <tt>props</tt> argument contains the properties defined for this module. The
module can do any initialization it needs in this method. If the method
returns without throwing an exception, the Enterprise Server assumes the module realm is ready
to service audit requests. If an exception is thrown, the module is disabled.</p><pre>public void authentication(String user, String realm, boolean success)</pre><p><a name="indexterm-288"></a><a name="indexterm-289"></a>This method is invoked when an authentication request has been processed by a
realm for the given user. The <tt>success</tt> flag indicates whether the authorization was granted
or denied.</p><pre>public void webInvocation(String user, HttpServletRequest req, String type, boolean success)</pre><p><a name="indexterm-290"></a>This method is invoked when a web container call has been processed by
authorization. The <tt>success</tt> flag indicates whether the authorization was granted or denied. The <tt>req</tt>
object is the standard <tt>HttpServletRequest</tt> object for this request. The <tt>type</tt> string is
one of <tt>hasUserDataPermission</tt> or <tt>hasResourcePermission</tt> (see <a href="http://www.jcp.org/en/jsr/detail?id=115">JSR 115</a>).</p><pre>public void ejbInvocation(String user, String ejb, String method, boolean success)</pre><p>This method is invoked when an EJB container call has been processed by
authorization. The <tt>success</tt> flag indicates whether the authorization was granted or denied. The
<tt>ejb</tt> and <tt>method</tt> strings describe the EJB component and its method that is
being invoked.</p><pre>public void webServiceInvocation(String uri, String endpoint, boolean success)</pre><p>This method is invoked during validation of a web service request in which
the endpoint is a servlet. The <tt>uri</tt> is the URL representation of the
web service endpoint. The <tt>endpoint</tt> is the name of the endpoint representation.
The <tt>success</tt> flag indicates whether the authorization was granted or denied.</p><pre>public void ejbAsWebServiceInvocation(String endpoint, boolean success)</pre><p>This method is invoked during validation of a web service request in which
the endpoint is a stateless session bean. The <tt>endpoint</tt> is the name of
the endpoint representation. The <tt>success</tt> flag indicates whether the authorization was granted or
denied.</p>

<a name="beabx"></a><h3>The <tt>server.policy</tt> File</h3>
<a name="indexterm-291"></a><a name="indexterm-292"></a><p>Each Enterprise Server domain has its own global J2SE policy file, located in
<i>domain-dir</i><tt>/config</tt>. The file is named <tt>server.policy</tt>.</p><p><a name="indexterm-293"></a>The Enterprise Server is a Java EE compliant application server. As such, it
follows the requirements of the Java EE specification, including the presence of the
security manager (the Java component that enforces the policy) and a limited permission set
for Java EE application code.</p><p>This section covers the following topics:</p>
<ul><li><p><a href="#beaby">Default Permissions</a></p></li>
<li><p><a href="#gilzz">System Properties</a></p></li>
<li><p><a href="#beabz">Changing Permissions for an Application</a></p></li>
<li><p><a href="#gbyah">Enabling and Disabling the Security Manager</a></p></li></ul>


<a name="beaby"></a><h4>Default Permissions</h4>
<a name="indexterm-294"></a><a name="indexterm-295"></a><p>Internal server code is granted all permissions. These are covered by the <tt>AllPermission</tt>
grant blocks to various parts of the server infrastructure code. Do not modify
these entries.</p><p>Application permissions are granted in the default grant block. These permissions apply to
all code not part of the internal server code listed previously. The Enterprise
Server does not distinguish between EJB and web module permissions. All code is granted
the minimal set of web component permissions (which is a superset of the
EJB minimal set). Do not modify these entries.</p><p>A few permissions above the minimal set are also granted in the default
<tt>server.policy</tt> file. These are necessary due to various internal dependencies of the server
implementation. Java EE application developers must not rely on these additional permissions. In some
cases, deleting these permissions might be appropriate. For example, one additional permission is
granted specifically for using connectors. If connectors are not used in a particular
domain, you should remove this permission, because it is not otherwise necessary.</p>

<a name="gilzz"></a><h4>System Properties</h4>
<p>The following predefined system properties, also called variables, are available for use in
the <tt>server.policy</tt> file. The system property most frequently used in <tt>server.policy</tt> is <tt>${com.sun.aas.instanceRoot}</tt>.
For more information about system properties, see the <tt>asadmin create-system-properties</tt> command in the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p><h6>Table&#160;5-1 Predefined System Properties</h6><table><col width="24%"><col width="15%"><col width="60%"><tr><th align="left" valign="top" scope="column"><p>Property</p></th>
<th align="left" valign="top" scope="column"><p>Default</p></th>
<th align="left" valign="top" scope="column"><p>Description</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.installRoot</tt></p></td>
<td align="left" valign="top" scope="row"><p>depends on
operating system</p></td>
<td align="left" valign="top" scope="row"><p>Specifies the directory where the Enterprise Server is installed.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.instanceRoot</tt></p></td>
<td align="left" valign="top" scope="row"><p>depends on operating
system</p></td>
<td align="left" valign="top" scope="row"><p>Specifies the top level directory for a server instance.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.hostName</tt></p></td>
<td align="left" valign="top" scope="row"><p>none</p></td>
<td align="left" valign="top" scope="row"><p>Specifies the name of
the host (machine).</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.javaRoot</tt></p></td>
<td align="left" valign="top" scope="row"><p>depends on operating system</p></td>
<td align="left" valign="top" scope="row"><p>Specifies the installation directory for the Java
runtime.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.imqLib</tt></p></td>
<td align="left" valign="top" scope="row"><p>depends on operating system</p></td>
<td align="left" valign="top" scope="row"><p>Specifies the library directory for the Sun GlassFish Message
Queue software.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.configName</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>server-config</tt></p></td>
<td align="left" valign="top" scope="row"><p>Specifies the name of the configuration used by a server instance.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.instanceName</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>server1</tt></p></td>
<td align="left" valign="top" scope="row"><p>Specifies
the name of the server instance. This property is not used in the
default configuration, but can be used to customize configuration.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>com.sun.aas.domainName</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>domain1</tt></p></td>
<td align="left" valign="top" scope="row"><p>Specifies the name of the
domain. This property is not used in the default configuration, but can be
used to customize configuration.</p></td>
</tr>
</table>

<a name="beabz"></a><h4>Changing Permissions for an Application</h4>
<a name="indexterm-296"></a><a name="indexterm-297"></a><p>The default policy for each domain limits the permissions of Java EE deployed
applications to the minimal set of permissions required for these applications to operate
correctly. Do not add extra permissions to the default set (the grant block
with no codebase, which applies to all code). Instead, add a new grant
block with a codebase specific to the applications requiring the extra permissions, and
only add the minimally necessary permissions in that block. </p><p>If you develop multiple applications that require more than this default set of
permissions, you can add the custom permissions that your applications need. The <tt>com.sun.aas.instanceRoot</tt>
variable refers to the <i>domain-dir</i>. For example:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/-" {
...
}</pre><p>You can add permissions to stub code with the following grant block:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/generated/-" {
...
}</pre><p>In general, you should add extra permissions only to the applications or modules
that require them, not to all applications deployed to a domain. For example:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/MyApp/-" {
...
}</pre><p>For a module:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/MyModule/-" {
...
}</pre>
<hr><p><b>Note - </b>Deployment directories may change between Enterprise Server releases.</p>
<hr>
<p>An alternative way to add permissions to a specific application or module is
to edit the <tt>granted.policy</tt> file for that application or module. The <tt>granted.policy</tt> file is
located in the <i>domain-dir</i><tt>/generated/policy/</tt><i>app-or-module-name</i> directory. In this case, you add permissions to the
default grant block. Do not delete permissions from this file.</p><p>When the application server policy subsystem determines that a permission should not be
granted, it logs a <tt>server.policy</tt> message specifying the permission that was not granted
and the protection domains, with indicated code source and principals that failed the protection
check. For example, here is the first part of a typical message:</p><pre>[#|2005-12-17T16:16:32.671-0200|INFO|sun-appserver-pe9.1|
javax.enterprise.system.core.security|_ThreadID=14;_ThreadName=Thread-31;|
JACC Policy Provider: PolicyWrapper.implies, context(null)- 
permission((java.util.PropertyPermission java.security.manager write)) 
domain that failed(ProtectionDomain
(file:/E:/glassfish/domains/domain1/applications/cejug-clfds/ ... )
...</pre><p>Granting the following permission eliminates the message:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/cejug-clfds/-" {
    permission java.util.PropertyPermission "java.security.manager", "write";
}</pre>
<hr><p><b>Note - </b>Do not add <tt>java.security.AllPermission</tt> to the <tt>server.policy</tt> file for application code. Doing so completely
defeats the purpose of the security manager, yet you still get the performance
overhead associated with it.</p>
<hr>
<p>As noted in the Java EE specification, an application should provide documentation of
the additional permissions it needs. If an application requires extra permissions but does
not document the set it needs, contact the application author for details.</p><p>As a last resort, you can iteratively determine the permission set an application
needs by observing <tt>AccessControlException</tt> occurrences in the server log. </p><p><a name="indexterm-298"></a><a name="indexterm-299"></a>If this is not sufficient, you can add the <tt>-Djava.security.debug=failure</tt> JVM option to the
domain. Use the following <tt>asadmin create-jvm-options</tt> command, then restart the server:</p><pre>asadmin create-jvm-options -Djava.security.debug=failure</pre><p>For more information about the <tt>asadmin create-jvm-options</tt> command, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p><p>You can use the J2SE standard <tt>policytool</tt> or any text editor to edit
the <tt>server.policy</tt> file. For more information, see <a href="http://java.sun.com/docs/books/tutorial/security/tour2/index.html">http://java.sun.com/docs/books/tutorial/security/tour2/index.html</a>.</p><p>For detailed information about policy file syntax, see <a href="http://java.sun.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#FileSyntax">http://java.sun.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#FileSyntax</a>.</p><p>For information about using system properties in the <tt>server.policy</tt> file, see <a href="http://java.sun.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#PropertyExp">http://java.sun.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#PropertyExp</a>.</p><p>For detailed information about the permissions you can set in the <tt>server.policy</tt> file,
see <a href="http://java.sun.com/javase/6/docs/technotes/guides/security/permissions.html">http://java.sun.com/javase/6/docs/technotes/guides/security/permissions.html</a>.</p><p>The Javadoc for the <tt>Permission</tt> class is at <a href="http://java.sun.com/javase/6/docs/api/java/security/Permission.html">http://java.sun.com/javase/6/docs/api/java/security/Permission.html</a>.</p>

<a name="gbyah"></a><h4>Enabling and Disabling the Security Manager</h4>
<a name="indexterm-300"></a><p>The security manager is disabled by default.</p><p>In a production environment, you may be able to safely disable the security
manager if all of the following are true:</p>
<ul><li><p>Performance is critical</p></li>
<li><p>Deployment to the production server is carefully controlled</p></li>
<li><p>Only trusted applications are deployed</p></li>
<li><p>Applications don't need policy enforcement</p></li></ul>
<p>Disabling the security manager may improve performance significantly for some types of applications.
To disable the security manager, do one of the following:</p>
<ul><li><p><a name="indexterm-301"></a>To use the Administration Console, open the Security component under the relevant configuration, and uncheck the Security Manager Enabled box. Then restart the server. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-302"></a><a name="indexterm-303"></a>Use the following <tt>asadmin delete-jvm-options</tt> command, then restart the server:</p><pre>asadmin delete-jvm-options -Djava.security.manager</pre><p>To re-enable the security manager, use the corresponding <tt>create-jvm-options</tt> command. For more information about the <tt>create-jvm-options</tt> and <tt>asadmin delete-jvm-options</tt> commands, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p></li></ul>


<a name="beaca"></a><h3>Configuring Message Security for Web Services</h3>
<a name="indexterm-304"></a><a name="indexterm-305"></a><a name="indexterm-306"></a><p>In <b>message security</b>, security information is applied at the message layer and travels along
with the web services message. Web Services Security (WSS) is the use of
XML Encryption and XML Digital Signatures to secure messages. WSS profiles the use of
various security tokens including X.509 certificates, Security Assertion Markup Language (SAML) assertions, and
username/password tokens to achieve this.</p><p>Message layer security differs from transport layer security in that it can be
used to decouple message protection from message transport so that messages remain protected
after transmission, regardless of how many hops they travel.</p>
<hr><p><b>Note - </b>Message security (JSR 196) is supported only in the full Enterprise Server, not
in the Web Profile.</p>
<hr>

<hr><p><b>Note - </b><a name="indexterm-307"></a>In this release of the Enterprise Server, message layer annotations are not supported.</p>
<hr>
<p>For more information about web services, see <a href="p11.html">Chapter&#160;6, Developing Web Services</a>.</p><p>For more information about message security, see the following:</p>
<ul><li><p><a href="http://docs.sun.com/doc/820-7627/bnbwj?a=view">Chapter 19, Introduction to Security in the Java EE Platform, in <i>The Java EE 6 Tutorial, Volume I</i></a></p></li>
<li><p><a href="http://docs.sun.com/doc/820-7692/ablrk?a=view">Chapter 13, Administering Message Security, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a></p></li>
<li><p><a name="indexterm-308"></a><a href="http://www.jcp.org/en/jsr/detail?id=196">JSR 196</a>, Java Authentication Service Provider Interface for Containers</p></li>
<li><p><a name="indexterm-309"></a>The Liberty Alliance Project specifications at <a href="http://www.projectliberty.org/resources/specifications.php">http://www.projectliberty.org/resources/specifications.php</a></p></li>
<li><p><a name="indexterm-310"></a><a name="indexterm-311"></a><a name="indexterm-312"></a>The Oasis Web Services Security (WSS) specification at <a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf">http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf</a></p></li>
<li><p>The Web Services Interoperability Organization (WS-I) Basic Security Profile (BSP) specification at <a href="http://www.ws-i.org/Profiles/BasicSecurityProfile-1.0.html">http://www.ws-i.org/Profiles/BasicSecurityProfile-1.0.html</a></p></li>
<li><p>The XML and Web Services Security page at <a href="https://xwss.dev.java.net/">https://xwss.dev.java.net/</a></p></li>
<li><p>The WSIT page at <a href="https://wsit.dev.java.net/">https://wsit.dev.java.net/</a></p></li></ul>
<p>The following web services security topics are discussed in this section:</p>
<ul><li><p><a href="#gbjxw">Message Security Providers</a></p></li>
<li><p><a href="#beacb">Message Security Responsibilities</a></p></li>
<li><p><a href="#beacf">Application-Specific Message Protection</a></p></li>
<li><p><a href="#beaci">Understanding and Running the Sample Application</a></p></li></ul>


<a name="gbjxw"></a><h4>Message Security Providers</h4>
<p>When you first install the Enterprise Server, the providers <tt>XWS_ClientProvider</tt> and <tt>XWS_ServerProvider</tt>
are configured but disabled. You can enable them in one of the following
ways:</p>
<ul><li><p><a name="indexterm-313"></a>To enable the message security providers using the Administration Console, open the Security component under the relevant configuration, select the Message Security component, and select SOAP. Then select <tt>XWS_ServerProvider</tt> from the Default Provider list and <tt>XWS_ClientProvider</tt> from the Default Client Provider list. For details, click the Help button in the Administration Console.</p></li>
<li><p>You can enable the message security providers using the following commands.</p><pre>asadmin set 
server-config.security-service.message-security-config.SOAP.default_provider=XWS_ServerProvider
asadmin set 
server-config.security-service.message-security-config.SOAP.default_client_provider=XWS_ClientProvider</pre><p>For more information about the <tt>asadmin set</tt> command, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.<a name="indexterm-314"></a><a name="indexterm-315"></a></p></li></ul>
<p>The example described in <a href="#beaci">Understanding and Running the Sample Application</a> uses the <tt>ClientProvider</tt> and <tt>ServerProvider</tt> providers, which are
enabled when the <tt>asant</tt> targets are run. You don&#8217;t need to enable these
on the Enterprise Server prior to running the example.</p><p>If you install the Access Manager, you have these additional provider choices:</p>
<ul><li><p><tt>AMClientProvider</tt> and <tt>AMServerProvider</tt> &#8211; These providers secure web services and Simple Object Access Protocol (SOAP) messages using either WS-I BSP or Liberty ID-WSF tokens. These providers are used automatically if they are configured as the default providers. If you wish to override any provider settings, you can configure these providers in <tt>message-security-binding</tt> elements in the <tt>sun-web.xml</tt>, <tt>sun-ejb-jar.xml</tt>, and <tt>sun-application-client.xml</tt> deployment descriptor files.</p></li>
<li><p><tt>AMHttpProvider</tt> &#8211; This provider handles the initial end user authentication for securing web services using Liberty ID-WSF tokens and redirects requests to the Access Manager for single sign-on. To use this provider, specify it in the <tt>httpservlet-security-provider</tt> attribute of the <tt>sun-web-app</tt> element in the <tt>sun-web.xml</tt> file.</p></li></ul>
<p>Liberty specifications can be viewed at <a href="http://www.projectliberty.org/resources/specifications.php">http://www.projectliberty.org/resources/specifications.php</a>. The WS-I BSP specification can
be viewed at <a href="http://www.ws-i.org/Profiles/BasicSecurityProfile-1.0.html">http://www.ws-i.org/Profiles/BasicSecurityProfile-1.0.html</a>.</p><p>For more information about the Sun-specific deployment descriptor files, see the <a href="http://docs.sun.com/doc/820-7693"><i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p><p>For information about configuring these providers in the Enterprise Server, see <a href="http://docs.sun.com/doc/820-7692/ablrk?a=view">Chapter 13, Administering Message Security, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a>. For additional
information about overriding provider settings, see <a href="#beacf">Application-Specific Message Protection</a>.</p><p>You can create new message security providers in one of the following ways:</p>
<ul><li><p><a name="indexterm-316"></a>To create a message security provider using the Administration Console, open the Security component under the relevant configuration, and select the Message Security component. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-317"></a><a name="indexterm-318"></a>You can use the <tt></tt><tt>asadmin create-message-security-provider</tt> command to create a message security provider. For details, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p></li></ul>
<p>In addition, you can set a few optional provider properties using the
<tt>asadmin set</tt> command. For example:</p><pre>asadmin set server-config.security-service.message-security-config.provider-config.property.debug=true</pre><p>The following table describes these message security provider properties.</p><h6>Table&#160;5-2 Message Security Provider Properties</h6><table><col width="15%"><col width="13%"><col width="70%"><tr><th align="left" valign="top" scope="column"><p>Property</p></th>
<th align="left" valign="top" scope="column"><p>Default</p></th>
<th align="left" valign="top" scope="column"><p>Description</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-319"></a><tt>security.config</tt></p></td>
<td align="left" valign="top" scope="row"><p><i>domain-dir</i><tt>/config/wss-server-config-1.0.xml</tt></p></td>
<td align="left" valign="top" scope="row"><p>Specifies the location of the
message security configuration file. To point to a configuration file in the <i>domain-dir</i><tt>/config</tt>
directory, use the system property <tt>${com.sun.aas.instanceRoot}/config/</tt>, for example:</p><p><tt>${com.sun.aas.instanceRoot}/config/wss-server-config-1.0.xml</tt></p><p>See <a href="#gilzz">System Properties</a>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-320"></a><tt>debug</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>false</tt></p></td>
<td align="left" valign="top" scope="row"><p>If <tt>true</tt>, enables dumping
of server provider debug messages to the server log.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-321"></a><tt>dynamic.username.password</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>false</tt></p></td>
<td align="left" valign="top" scope="row"><p>If <tt>true</tt>, signals the provider
runtime to collect the user name and password from the <tt>CallbackHandler</tt> for each request.
If <tt>false</tt>, the user name and password for <tt>wsse:UsernameToken(s)</tt> is collected once, during module
initialization. This property is only applicable for a <tt>ClientAuthModule</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-322"></a><tt>encryption.key.alias</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>s1as</tt></p></td>
<td align="left" valign="top" scope="row"><p>Specifies the encryption key
used by the provider. The key is identified by its <tt>keystore</tt> alias.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-323"></a><tt>signature.key.alias</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>s1as</tt></p></td>
<td align="left" valign="top" scope="row"><p>Specifies the
signature key used by the provider. The key is identified by its <tt>keystore</tt>
alias.</p></td>
</tr>
</table>

<a name="beacb"></a><h4>Message Security Responsibilities</h4>
<p><a name="indexterm-324"></a>In the Enterprise Server, the system administrator and application deployer roles are expected
to take primary responsibility for configuring message security. In some situations, the application developer
may also contribute, although in the typical case either of the other roles
may secure an existing application without changing its implementation and without involving the
developer. The responsibilities of the various roles are defined in the following sections:</p>
<ul><li><p><a href="#beacc">Application Developer</a></p></li>
<li><p><a href="#beacd">Application Deployer</a></p></li>
<li><p><a href="#beace">System Administrator</a></p></li></ul>


<a name="beacc"></a><h5>Application Developer</h5>
<p>The application developer can turn on message security, but is not responsible for
doing so. Message security can be set up by the system administrator so
that all web services are secured, or set up by the application deployer
when the provider or protection policy bound to the application must be different
from that bound to the container.</p><p>The application developer is responsible for the following:</p>
<ul><li><p>Determining if an application-specific message protection policy is required by the application. If so, ensuring that the required policy is specified at application assembly which may be accomplished by communicating with the application deployer.</p></li>
<li><p>Determining if message security is necessary at the Enterprise Server level. If so, ensuring that this need is communicated to the system administrator, or taking care of implementing message security at the Enterprise Server level.</p></li></ul>


<a name="beacd"></a><h5>Application Deployer</h5>
<p>The application deployer is responsible for the following:</p>
<ul><li><p>Specifying (at application assembly) any required application-specific message protection policies if such policies have not already been specified by upstream roles (the developer or assembler)</p></li>
<li><p>Modifying Sun-specific deployment descriptors to specify application-specific message protection policies information (message-security-binding elements) to web service endpoint and service references</p></li></ul>
<p>These security tasks are discussed in <a href="#beacf">Application-Specific Message Protection</a>. A sample application using message
security is discussed in <a href="#beaci">Understanding and Running the Sample Application</a>.</p>

<a name="beace"></a><h5>System Administrator</h5>
<p>The system administrator is responsible for the following:</p>
<ul><li><p>Configuring message security providers on the Enterprise Server.</p></li>
<li><p>Managing user databases.</p></li>
<li><p>Managing keystore and truststore files.</p></li>
<li><p>Installing the sample. This is only done if the <tt>xms</tt> sample application is used to demonstrate the use of message layer web services security.</p></li></ul>
<p>A system administrator uses the Administration Console to manage server security settings and
uses a command line tool to manage certificate databases. Certificates and private keys
are stored in key stores and are managed with <tt>keytool</tt>. System administrator tasks
are discussed in <a href="http://docs.sun.com/doc/820-7692/ablrk?a=view">Chapter 13, Administering Message Security, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a>.</p>

<a name="beacf"></a><h4>Application-Specific Message Protection</h4>
<a name="indexterm-325"></a><p>When the Enterprise Server provided configuration is insufficient for your security needs, and
you want to override the default protection, you can apply <b>application-specific message security</b> to a web
service.</p><p>Application-specific security is implemented by adding the message security binding to the web
service endpoint, whether it is an EJB or servlet web service endpoint. Modify
Sun-specific XML files to add the message binding information.</p><p> Message security can also be specified using a WSIT security policy in
the WSDL file. For details, see the WSIT page at <a href="https://wsit.dev.java.net/">https://wsit.dev.java.net/</a>.</p><p>For more information about message security providers, see <a href="#gbjxw">Message Security Providers</a>.</p><p>For more details on message security binding for EJB web services, servlet web
services, and clients, see the XML file descriptions in <a href="http://docs.sun.com/doc/820-7693/beaqi?a=view">Appendix C, <i>Elements of the Enterprise Server Deployment Descriptors,</i> in <i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p>
<ul><li><p>For <tt>sun-ejb-jar.xml</tt>, see <a href="http://docs.sun.com/doc/820-7693/beaqm?a=view">The sun-ejb-jar.xml File in <i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p></li>
<li><p>For <tt>sun-web.xml</tt>, see <a href="http://docs.sun.com/doc/820-7693/beaql?a=view">The sun-web.xml File in <i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p></li>
<li><p>For <tt>sun-application-client.xml</tt>, see <a href="http://docs.sun.com/doc/820-7693/beaqo?a=view">The sun-application-client.xml file in <i>Sun GlassFish Enterprise Server v3 Preview Application Deployment Guide</i></a>.</p></li></ul>
<p>This section contains the following topics:</p>
<ul><li><p><a href="#beacg">Using a Signature to Enable Message Protection for All Methods</a></p></li>
<li><p><a href="#beach">Configuring Message Protection for a Specific Method Based on Digital Signatures</a></p></li></ul>


<a name="beacg"></a><h5>Using a Signature to Enable Message Protection for All Methods</h5>
<p>To enable message protection for all methods using digital signature, update the <tt>message-security-binding</tt>
element for the EJB web service endpoint in the application&#8217;s <tt>sun-ejb-jar.xml</tt> file. In
this file, add <tt>request-protection</tt> and <tt>response-protection</tt> elements, which are analogous to the
<tt>request-policy</tt> and <tt>response-policy</tt> elements discussed in <a href="http://docs.sun.com/doc/820-7692/ablrk?a=view">Chapter 13, Administering Message Security, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a>. To apply the same protection mechanisms for
all methods, leave the method-name element blank. <a href="#beach">Configuring Message Protection for a Specific Method Based on Digital Signatures</a> discusses listing specific methods or using
wildcard characters.</p><p>This section uses the sample application discussed in <a href="#beaci">Understanding and Running the Sample Application</a> to apply application-level message
security to show only the differences necessary for protecting web services using various
mechanisms.</p>

<a name="fvyag"></a><h5>To Enable Message Protection for All Methods Using Digital Signature</h5>
<ol>
<li><b>In a text editor, open the application&#8217;s <tt>sun-ejb-jar.xml</tt> file. </b><p>For the <tt>xms</tt> example, this file is located in the directory <i>app-dir</i><tt>/xms-ejb/src/conf</tt>, where
<i>app-dir</i> is defined in <a href="#beacj">To Set Up the Sample Application</a>.</p></li>
<li><b>Modify the <tt>sun-ejb-jar.xml</tt> file by adding the <tt>message-security-binding</tt> element as shown:</b><pre>&#60;sun-ejb-jar>
  &#60;enterprise-beans>
    &#60;unique-id>1&#60;/unique-id>
    &#60;ejb>
      &#60;ejb-name>HelloWorld&#60;/ejb-name>
      &#60;jndi-name>HelloWorld&#60;/jndi-name>
      &#60;webservice-endpoint>
        &#60;port-component-name>HelloIF&#60;/port-component-name>
        &#60;endpoint-address-uri>service/HelloWorld&#60;/endpoint-address-uri>
        &#60;message-security-binding auth-layer="SOAP">
          &#60;message-security>
            &#60;request-protection auth-source="content" />
            &#60;response-protection auth-source="content"/>
          &#60;/message-security>
        &#60;/message-security-binding>
      &#60;/webservice-endpoint>
    &#60;/ejb>
  &#60;/enterprise-beans>
&#60;/sun-ejb-jar></pre></li>
<li><b>Compile, deploy, and run the application as described in <a href="#beack">To Run the Sample Application</a>.</b></li></ol>

<a name="beach"></a><h5>Configuring Message Protection for a Specific Method Based on Digital Signatures</h5>
<p>To enable message protection for a specific method, or for a set of
methods that can be identified using a wildcard value, follow these steps. As
in the example discussed in <a href="#beacg">Using a Signature to Enable Message Protection for All Methods</a>, to enable message protection for a specific
method, update the <tt>message-security-binding</tt> element for the EJB web service endpoint in
the application&#8217;s <tt>sun-ejb-jar.xml</tt> file. To this file, add <tt>request-protection</tt> and <tt>response-protection</tt> elements,
which are analogous to the <tt>request-policy</tt> and <tt>response-policy</tt> elements discussed in <a href="http://docs.sun.com/doc/820-7692/ablrk?a=view">Chapter 13, Administering Message Security, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a>. The administration
guide includes a table listing the set and order of security operations for
different request and response policy configurations.</p><p>This section uses the sample application discussed in <a href="#beaci">Understanding and Running the Sample Application</a> to apply application-level message
security to show only the differences necessary for protecting web services using various
mechanisms.</p>

<a name="fvybb"></a><h5>To Enable Message Protection for a Particular Method or Set of Methods Using Digital Signature</h5>
<ol>
<li><b>In a text editor, open the application&#8217;s <tt>sun-ejb-jar.xml</tt> file. </b><p>For the <tt>xms</tt> example, this file is located in the directory <i>app-dir</i><tt>/xms-ejb/src/conf</tt>, where
<i>app-dir</i> is defined in <a href="#beacj">To Set Up the Sample Application</a>.</p></li>
<li><b>Modify the <tt>sun-ejb-jar.xml</tt> file by adding the <tt>message-security-binding</tt> element as shown:</b><pre>&#60;sun-ejb-jar>
  &#60;enterprise-beans>
  &#60;unique-id>1&#60;/unique-id>
    &#60;ejb>
      &#60;ejb-name>HelloWorld&#60;/ejb-name>
      &#60;jndi-name>HelloWorld&#60;/jndi-name>
      &#60;webservice-endpoint>
        &#60;port-component-name>HelloIF&#60;/port-component-name>
        &#60;endpoint-address-uri>service/HelloWorld&#60;/endpoint-address-uri>
        &#60;message-security-binding auth-layer="SOAP">
          &#60;message-security>
            &#60;message>
              &#60;java-method>
                &#60;method-name>ejbCreate&#60;/method-name>
              &#60;/java-method>
            &#60;/message>
            &#60;message>
              &#60;java-method>
                &#60;method-name>sayHello&#60;/method-name>
              &#60;/java-method>
            &#60;/message>
            &#60;request-protection auth-source="content" />
            &#60;response-protection auth-source="content"/>
          &#60;/message-security>
        &#60;/message-security-binding>
      &#60;/webservice-endpoint>
    &#60;/ejb>
  &#60;/enterprise-beans>
&#60;/sun-ejb-jar></pre></li>
<li><b>Compile, deploy, and run the application as described in <a href="#beack">To Run the Sample Application</a>.</b></li></ol>

<a name="beaci"></a><h4>Understanding and Running the Sample Application</h4>
<a name="indexterm-326"></a><p>This section discusses the WSS sample application. This sample application is installed on
your system only if you installed the J2EE 1.4 samples. If you have
not installed these samples, see <a href="#beacj">To Set Up the Sample Application</a>.</p><p>The objective of this sample application is to demonstrate how a web service
can be secured with WSS. The web service in the <tt>xms</tt> example
is a simple web service implemented using a Java EE EJB endpoint and
a web service endpoint implemented using a servlet. In this example, a service
endpoint interface is defined with one operation, <tt>sayHello</tt>, which takes a string then sends
a response with <tt>Hello</tt> prefixed to the given string. You can view the
WSDL file for the service endpoint interface at <i>app-dir</i><tt>/xms-ejb/src/conf/HelloWorld.wsdl</tt>, where <i>app-dir</i> is defined
in <a href="#beacj">To Set Up the Sample Application</a>.</p><p>In this application, the client looks up the service using the JNDI name
<tt>java:comp/env/service/HelloWorld</tt> and gets the port information using a static stub to invoke the
operation using a given name. For the name Duke, the client gets the
response <tt>Hello Duke!</tt></p><p><a name="indexterm-327"></a>This example shows how to use message security for web services at the
Enterprise Server level. For information about using message security at the application level,
see <a href="#beacf">Application-Specific Message Protection</a>. The WSS message security mechanisms implement message-level authentication (for example, XML digital
signature and encryption) of SOAP web services invocations using the X.509 and username/password
profiles of the OASIS WS-Security standard, which can be viewed from the following URL:
<a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf">http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf</a>.</p><p>This section includes the following topics:</p>
<ul><li><p><a href="#beacj">To Set Up the Sample Application</a></p></li>
<li><p><a href="#beack">To Run the Sample Application</a></p></li></ul>


<a name="beacj"></a><h5>To Set Up the Sample Application</h5>
<h6>Before You Begin</h6><p>To have access to this sample application, you must have previously installed the
J2EE 1.4 samples. If the samples are not installed, follow the steps in
the following section. </p><p>After you follow these steps, the sample application is located in the directory
<i>as-install</i><tt>/j2ee14-samples/samples/webservices/security/ejb/apps/xms/</tt> or in a directory of your choice. For easy reference throughout the
rest of this section, this directory is referred to as simply <i>app-dir</i>.</p><ol>
<li><b>Go to the <a href="http://java.sun.com/j2ee/1.4/download.html">J2EE 1.4 download URL</a> in your browser.</b></li>
<li><b>Click on the Download button for the Samples Bundle.</b></li>
<li><b>Click on Accept License Agreement.</b></li>
<li><b>Click on the J2EE SDK Samples link.</b></li>
<li><b>Choose a location for the <tt>j2eesdk-1_4_03-samples.zip</tt> file.</b><p>Saving the file to <i>as-install</i> is recommended.</p></li>
<li><b>Unzip the file.</b><p>Unzipping to the <i>as-install</i><tt>/j2ee14&#8211;samples</tt> directory is recommended. For example, you can use the
following command.</p><pre>unzip j2eesdk-1_4_03-samples.zip -d j2ee14-samples</pre></li></ol>

<a name="beack"></a><h5>To Run the Sample Application</h5>
<ol>
<li><b>Make sure that the Enterprise Server is running.</b><p>Message security providers are set up when the <tt>asant</tt> targets are run, so you
do not need to configure these on the Enterprise Server prior to running
this example.</p></li>
<li><b>If you are not running HTTP on the default port of 8080, change
the WSDL file for the example to reflect the change, and change the
<tt>common.properties</tt> file to reflect the change as well. </b><p>The WSDL file for this example is located at <i>app-dir</i><tt>/xms-ejb/src/conf/HelloWorld.wsdl</tt>. The port
number is in the following section:</p><pre>&#60;service name="HelloWorld">
  &#60;port name="HelloIFPort" binding="tns:HelloIFBinding">
    &#60;soap:address location="http://localhost:8080/service/HelloWorld"/>
  &#60;/port>
&#60;/service></pre><p>Verify that the properties in the <i>as-install</i><tt>/samples/common.properties</tt> file are set properly for
your installation and environment. If you need a more detailed description of this
file, refer to the &#8220;Configuration&#8221; section for the web services security applications at
<i>as-install</i><tt>/j2ee14&#8211;samples/samples/webservices/security/docs/common.html#Logging</tt>.</p></li>
<li><b>Change to the <i>app-dir</i> directory.</b></li>
<li><b>Run the following <tt>asant</tt> targets to compile, deploy, and run the example application:</b><ol style="list-style-type: lower-alpha">
<li><b>To compile samples:</b><p><tt>asant</tt></p></li>
<li><b>To deploy samples:</b><p><tt>asant deploy</tt></p></li>
<li><b>To run samples:</b><p><tt>asant run</tt></p></li></ol><p>If the sample has compiled and deployed properly, you see the following response
on your screen after the application has run:</p><p><tt>run:[echo] Running the xms program:[exec] Established message level security : Hello Duke!</tt></p></li>
<li><b>To undeploy the sample, run the following <tt>asant</tt> target:</b><pre>asant undeploy</pre><p>All of the web services security examples use the same web service name
(<tt>HelloWorld</tt>) and web service ports. These examples show only the differences necessary for
protecting web services using various mechanisms. Make sure to undeploy an application when you
have completed running it. If you do not, you receive an <tt>Already in Use</tt>
error and deployment failures when you try to deploy another web services example
application.</p></li></ol>

<a name="beacm"></a><h3>Programmatic Login</h3>
<p><a name="indexterm-328"></a><a name="indexterm-329"></a><a name="indexterm-330"></a><a name="indexterm-331"></a>Programmatic login allows a deployed Java EE application or module to invoke a
login method. If the login is successful, a <tt>SecurityContext</tt> is established as if the
client had authenticated using any of the conventional Java EE mechanisms. Programmatic login
is supported for servlet and EJB components on the server side, and for
stand-alone or application clients on the client side. Programmatic login is useful for
an application having special needs that cannot be accommodated by any of the
Java EE standard authentication mechanisms.</p>
<hr><p><b>Note - </b>Programmatic login is specific to the Enterprise Server and not portable to other
application servers.</p>
<hr>
<p>This section contains the following topics:</p>
<ul><li><p><a href="#beacn">Programmatic Login Precautions</a></p></li>
<li><p><a href="#beaco">Granting Programmatic Login Permission</a></p></li>
<li><p><a href="#beacp">The <tt>ProgrammaticLogin</tt> Class</a></p></li></ul>


<a name="beacn"></a><h4>Programmatic Login Precautions</h4>
<p>The Enterprise Server is not involved in how the login information (<tt>user</tt>, <tt>password</tt>)
is obtained by the deployed application. Programmatic login places the burden on the application
developer with respect to assuring that the resulting system meets security requirements. If
the application code reads the authentication information across the network, the application determines whether
to trust the user.</p><p>Programmatic login allows the application developer to bypass the application server-supported authentication mechanisms
and feed authentication data directly to the security service. While flexible, this capability should
not be used without some understanding of security issues.</p><p>Since this mechanism bypasses the container-managed authentication process and sequence, the application developer
must be very careful in making sure that authentication is established before accessing any
restricted resources or methods. It is also the application developer&#8217;s responsibility to verify
the status of the login attempt and to alter the behavior of the
application accordingly.</p><p>The programmatic login state does not necessarily persist in sessions or participate in
single sign-on.</p><p>Lazy authentication is not supported for programmatic login. If an access check is
reached and the deployed application has not properly authenticated using the programmatic login
method, access is denied immediately and the application might fail if not coded to
account for this occurrence. One way to account for this occurrence is to
catch the access control or security exception, perform a programmatic login, and repeat
the request.</p>

<a name="beaco"></a><h4>Granting Programmatic Login Permission</h4>
<a name="indexterm-332"></a><p>The <tt>ProgrammaticLoginPermission</tt> permission is required to invoke the programmatic login mechanism for an
application if the security manager is enabled. For information about the security manager, see
<a href="#beabx">The <tt>server.policy</tt> File</a>. This permission is not granted by default to deployed applications because this is
not a standard Java EE mechanism.</p><p><a name="indexterm-333"></a>To grant the required permission to the application, add the following to the
<i>domain-dir</i><tt>/config/server.policy</tt> file:</p><pre>grant codeBase "file:<i>jar-file-path</i>" {
     permission com.sun.appserv.security.ProgrammaticLoginPermission
     "login";
 };</pre><p>The <i>jar-file-path</i> is the path to the application&#8217;s JAR file.</p>

<a name="beacp"></a><h4>The <tt>ProgrammaticLogin</tt> Class</h4>
<p><a name="indexterm-334"></a><a name="indexterm-335"></a>The <tt>com.sun.appserv.security.ProgrammaticLogin</tt> class enables a user to perform login programmatically.</p><p>For Javadoc tool pages relevant to programmatic login, go to <a href="http://java.sun.com/javaee/6/docs/api/">http://java.sun.com/javaee/6/docs/api/</a> and click
on the <tt>com.sun.appserv.security</tt> package.</p><p>The <tt>ProgrammaticLogin</tt> class has four <tt>login</tt> methods, two for servlets or JSP
files and two for EJB components.</p><p>The login methods for servlets or JSP files have the following signatures:</p><pre>public java.lang.Boolean login(String user, String password, 
    javax.servlet.http.HttpServletRequest request, 
    javax.servlet.http.HttpServletResponse response)</pre><pre>public java.lang.Boolean login(String user, String password, 
    String realm, javax.servlet.http.HttpServletRequest request, 
    javax.servlet.http.HttpServletResponse response, boolean errors) 
    throws java.lang.Exception</pre><p>The login methods for EJB components have the following signatures:</p><pre>public java.lang.Boolean login(String user, String password)</pre><pre>public java.lang.Boolean login(String user, String password, 
    String realm, boolean errors) throws java.lang.Exception</pre><p>All of these <tt>login</tt> methods accomplish the following:</p>
<ul><li><p>Perform the authentication</p></li>
<li><p>Return <tt>true</tt> if login succeeded, <tt>false</tt> if login failed</p></li></ul>
<p>The login occurs on the <tt>realm</tt> specified unless it is null, in which
case the domain&#8217;s default realm is used. The methods with no <tt>realm</tt> parameter
use the domain&#8217;s default realm.</p><p>If the <tt>errors</tt> flag is set to <tt>true</tt>, any exceptions encountered during the
login are propagated to the caller. If set to <tt>false</tt>, exceptions are thrown.</p><p>On the client side, <tt>realm</tt> and <tt>errors</tt> parameters are ignored and the actual
login does not occur until a resource requiring a login is accessed. A
<tt>java.rmi.AccessException</tt> with <tt>COBRA NO_PERMISSION</tt> occurs if the actual login fails.</p><p>The logout methods for servlets or JSP files have the following signatures:</p><pre>public java.lang.Boolean logout(HttpServletRequest request, 
    HttpServletResponse response)</pre><pre>public java.lang.Boolean logout(HttpServletRequest request, 
    HttpServletResponse response, boolean errors) 
    throws java.lang.Exception</pre><p>The logout methods for EJB components have the following signatures:</p><pre>public java.lang.Boolean logout()</pre><pre>public java.lang.Boolean logout(boolean errors) 
    throws java.lang.Exception</pre><p>All of these <tt>logout</tt> methods return <tt>true</tt> if logout succeeded, <tt>false</tt> if
logout failed.</p><p>If the <tt>errors</tt> flag is set to <tt>true</tt>, any exceptions encountered during the
logout are propagated to the caller. If set to <tt>false</tt>, exceptions are thrown.</p>

<a name="beacq"></a><h3>User Authentication for Single Sign-on</h3>
<a name="indexterm-336"></a><a name="indexterm-337"></a><p>The single sign-on feature of the Enterprise Server allows multiple web applications deployed
to the same virtual server to share the user authentication state. With single
sign-on enabled, users who log in to one web application become implicitly logged into
other web applications on the same virtual server that require the same authentication
information. Otherwise, users would have to log in separately to each web application
whose protected resources they tried to access.</p><p>A sample application using the single sign-on scenario could be a consolidated airline
booking service that searches all airlines and provides links to different airline web
sites. After the user signs on to the consolidated booking service, the user
information can be used by each individual airline site without requiring another sign-on.</p><p>Single sign-on operates according to the following rules:</p>
<ul><li><p>Single sign-on applies to web applications configured for the same realm and virtual server. The realm is defined by the <tt>realm-name</tt> element in the <tt>web.xml</tt> file. For information about virtual servers, see <a href="http://docs.sun.com/doc/820-7692/ablsw?a=view">Chapter 17, Administering Internet Connectivity, in <i>Sun GlassFish Enterprise Server v3 Administration Guide</i></a>.</p></li>
<li><p>As long as users access only unprotected resources in any of the web applications on a virtual server, they are not challenged to authenticate themselves.</p></li>
<li><p>As soon as a user accesses a protected resource in any web application associated with a virtual server, the user is challenged to authenticate himself or herself, using the login method defined for the web application currently being accessed.</p></li>
<li><p>After authentication, the roles associated with this user are used for access control decisions across all associated web applications, without challenging the user to authenticate to each application individually.</p></li>
<li><p>When the user logs out of one web application (for example, by invalidating the corresponding session), the user&#8217;s sessions in all web applications are invalidated. Any subsequent attempt to access a protected resource in any application requires the user to authenticate again.</p></li></ul>
<p>The single sign-on feature utilizes HTTP cookies to transmit a token that associates
each request with the saved user identity, so it can only be used
in client environments that support cookies.</p><p>To configure single sign-on, set the following virtual server properties:</p>
<ul><li><p><tt>sso-enabled</tt> - If <tt>false</tt>, single sign-on is disabled for this virtual server, and users must authenticate separately to every application on the virtual server. The default is <tt>false</tt>.</p></li>
<li><p><tt>sso-max-inactive-seconds</tt> - Specifies the time after which a user&#8217;s single sign-on record becomes eligible for purging if no client activity is received. Since single sign-on applies across several applications on the same virtual server, access to any of the applications keeps the single sign-on record active. The default value is 5 minutes (<tt>300</tt> seconds). Higher values provide longer single sign-on persistence for the users at the expense of more memory use on the server.</p></li>
<li><p><tt>sso-reap-interval-seconds</tt> - Specifies the interval between purges of expired single sign-on records. The default value is <tt>60</tt>.</p></li></ul>
<p>Here are example <tt>asadmin set</tt> commands with default values:</p><pre>asadmin set server-config.http-service.virtual-server.vsrv1.property.sso-enabled="true"
asadmin set server-config.http-service.virtual-server.vsrv1.property.sso-max-inactive-seconds="300"
asadmin set server-config.http-service.virtual-server.vsrv1.property.sso-reap-interval-seconds="60"</pre><p>For more information about the <tt>asadmin set</tt> command, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p>

<a name="gizel"></a><h3>Adding Authentication Mechanisms to the Servlet Container</h3>
<p>You can use JSR 196 in the web tier to facilitate the
injection of pluggable authentication modules within the servlet constraint processing engine. The Enterprise Server
includes implementations of a number of HTTP layer authentication mechanisms such as basic,
form, and digest authentication. You can add alternative implementations of the included mechanisms or
implementations of new mechanisms such as HTTP Negotiate/SPNEGO, OpenID, or CAS. JSR 196
server authentication modules are described in the following sections:</p>
<ul><li><p><a href="#gizfz">The Enterprise Server and JSR 196</a></p></li>
<li><p><a href="#gizdx">Writing a Server Authentication Module</a></p></li>
<li><p><a href="#gizeb">Sample Server Authentication Module</a></p></li>
<li><p><a href="#gizfa">Compiling and Installing a Server Authentication Module</a></p></li>
<li><p><a href="#gizfe">Configuring a Server Authentication Module</a></p></li>
<li><p><a href="#gizfm">Binding a Server Authentication Module to Your Application</a></p></li></ul>


<a name="gizfz"></a><h4>The Enterprise Server and JSR 196</h4>
<p>The Enterprise Server implements the Servlet Container Profile of JSR 196, Java Authentication
Service Provider Interface for Containers. JSR 196 defines a standard <b>service provider interface</b> (SPI) that extends
the concepts of the Java Authentication and Authorization Service (JAAS) to enable pluggability
of message authentication modules in message processing runtimes. The JSR 196 standard defines
profiles that establish contracts for the use of the SPI in specific contexts. The
Servlet Container Profile of JSR 196 defines the use of the SPI by
a Servlet container such that:</p>
<ul><li><p>The resulting container can be configured with new authentication mechanisms.</p></li>
<li><p>The container employs the configured mechanisms in its enforcement of the declarative servlet security model (declared in a <tt>web.xml</tt> file using <tt>security-constraint</tt> elements).</p></li></ul>
<p>The JSR 196 specification defines a simple message processing model composed of four
interaction points:</p>
<ol><li><p><tt>secureRequest</tt> on the client</p></li>
<li><p><tt>validateRequest</tt> on the server</p></li>
<li><p><tt>secureResponse</tt> on the server</p></li>
<li><p><tt>validateResponse</tt> on the client</p></li></ol>
<p>A message processing runtime uses the SPI at these interaction points to delegate
the corresponding message security processing to authentication providers, also called <b>authentication modules</b>, integrated into the
runtime by way of the SPI.</p><p>A compatible server-side message processing runtime, such as the Enterprise Server servlet container,
supports the <tt>validateRequest</tt> and <tt>secureResponse</tt> interaction points of the message processing model. The
servlet container uses the SPI at these interaction points to delegate the corresponding
message security processing to a <b>server authentication module</b> (SAM), integrated by the SPI into the container.</p>

<a name="gizdx"></a><h4>Writing a Server Authentication Module</h4>
<p>A key step in adding an authentication mechanism to a compatible server-side message
processing runtime such as the Enterprise Server servlet container is acquiring a SAM
that implements the desired authentication mechanism. One way to do that is to
write the SAM yourself.</p><p>A SAM implements the <tt>javax.security.auth.message.module.ServerAuthModule</tt> interface as defined by JSR 196. A
SAM is invoked indirectly by the message processing runtime at the <tt>validateRequest</tt> and
<tt>secureResponse</tt> interaction points. A SAM must implement the five methods of the <tt>ServerAuthModule</tt>
interface:</p>
<ul><li><p><tt>getSupportedMessageTypes()</tt> &#8212; An array of <tt>Class</tt> objects where each element defines a message type supported by the SAM. For a SAM to be compatible with the Servlet Container Profile, the returned array must include the <tt>HttpServletRequest.class</tt> and <tt>HttpServletResponse.class</tt> objects.</p></li>
<li><p><tt>initialize(MessagePolicy requestPolicy, MessagePolicy responsePolicy, CallbackHandler Map options)</tt> &#8212; The container calls this method to provide the SAM with configuration values and with a <tt>CallbackHandler</tt>. The configuration values are returned in the policy arguments and in the options <tt>Map</tt>. The SAM uses <tt>CallbackHandler</tt> to access services, such as password validation, provided by the container.</p></li>
<li><p><tt>AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject, Subject serviceSubject)</tt> &#8212; The container calls this method to process each received <tt>HttpServletRequest</tt>. The request and its associated <tt>HttpServletResponse</tt> are passed by the container to the SAM in the <tt>messageInfo</tt> argument. The SAM processes the request and may establish the response to be returned by the container. The SAM uses the provided <tt>Subject</tt> arguments to convey its authentication results. The SAM returns different status values to control the container's invocation processing. The status values and the circumstances under which they are returned are as follows:</p>
<ul><li><p><tt>AuthStatus.SUCCESS</tt> is returned when the application request message is successfully validated. The container responds to this status value by using the returned client <tt>Subject</tt> to invoke the target of the request. When this value is returned, the SAM (provided a custom <tt>AuthConfigProvider</tt> is not being used) must use its <tt>CallbackHandler</tt> to handle a <tt>CallerPrincipalCallback</tt> using the <tt>clientSubject</tt> as an argument to the callback.</p></li>
<li><p><tt>AuthStatus.SEND_CONTINUE</tt> indicates that message validation is incomplete and that the SAM has established a preliminary response as the response message in <tt>messageInfo</tt>. The container responds to this status value by sending the response to the client.</p></li>
<li><p><tt>AuthStatus.SEND_FAILURE</tt> indicates that message validation failed and that the SAM has established an appropriate failure response message in <tt>messageInfo</tt>. The container responds to this status value by sending the response to the client.</p></li>
<li><p><tt>AuthStatus.SEND_SUCCESS</tt> is not typically returned. This status value indicates the end of a multi-message security dialog originating after the service interaction and during the processing of the application response. The container responds to this status value by sending the response to the client.</p></li></ul>
<p>The <tt>validateRequest</tt> method may also throw an <tt>AuthException</tt> to indicate that the message processing by the SAM failed without establishing a failure response message in <tt>messageInfo</tt>.</p></li>
<li><p><tt>secureResponse(MessageInfo messageInfo, Subject serviceSubject)</tt> &#8212; The container calls this method before sending a response, resulting from an application invocation, to the client. The response is passed to the SAM in the <tt>messageInfo</tt> argument. In most cases, this method should just return the <tt>SEND_SUCCESS</tt> status.</p></li>
<li><p><tt>cleanSubject(MessageInfo messageInfo, Subject subject)</tt> &#8212; This method removes the mechanism-specific principals, credentials, or both from the subject. This method is not currently called by the container. A legitimate implementation could remove all the principals from the argument subject.</p></li></ul>
<p>See the <i>Servlet Container Profile</i> section in the JSR 196 specification for additional background and
details.</p>

<a name="gizeb"></a><h4>Sample Server Authentication Module</h4>
<p>The class <tt>MySam.java</tt> is a sample SAM implementation. Notice that the sample implements
the five methods of the <tt>ServerAuthModule</tt> interface. This SAM implements an approximation
of HTTP basic authentication.</p><pre>package tip.sam;

   import java.io.IOException;
   import java.util.Map;
   import javax.security.auth.Subject;
   import javax.security.auth.callback.Callback;
   import javax.security.auth.callback.CallbackHandler;
   import javax.security.auth.callback.UnsupportedCallbackException;
   import javax.security.auth.message.AuthException;
   import javax.security.auth.message.AuthStatus;
   import javax.security.auth.message.MessageInfo;
   import javax.security.auth.message.MessagePolicy;
   import javax.security.auth.message.callback.CallerPrincipalCallback;
   import javax.security.auth.message.callback.GroupPrincipalCallback;
   import javax.security.auth.message.callback.PasswordValidationCallback;
   import javax.security.auth.message.module.ServerAuthModule;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import org.apache.catalina.util.Base64;

   public class MySam implements ServerAuthModule {

      protected static final Class[]
        supportedMessageTypes = new Class[]{
          HttpServletRequest.class,
          HttpServletResponse.class
      };

      private MessagePolicy requestPolicy;
      private MessagePolicy responsePolicy;
      private CallbackHandler handler;
      private Map options;
      private String realmName = null;
      private String defaultGroup[] = null;
      privte static final String REALM_PROPERTY_NAME =
          "realm.name";
      private static final String GROUP_PROPERTY_NAME =
          "group.name";
      private static final String BASIC = "Basic";
      static final String AUTHORIZATION_HEADER =
          "authorization";
      static final String AUTHENTICATION_HEADER =
          "WWW-Authenticate";

      public void initialize(MessagePolicy reqPolicy,
              MessagePolicy resPolicy,
              CallbackHandler cBH, Map opts)
              throws AuthException {
          requestPolicy = reqPolicy;
          responsePolicy = resPolicy;
          handler = cBH;
          options = opts;
          if (options != null) {
              realmName = (String)
                  options.get(REALM_PROPERTY_NAME);
              if (options.containsKey(GROUP_PROPERTY_NAME)) {
                  defaultGroup = new String[]{(String)
                      options.get(GROUP_PROPERTY_NAME)};
              }
          }
      }

      public Class[] getSupportedMessageTypes() {
          return supportedMessageTypes;
      }

      public AuthStatus validateRequest(
              MessageInfo msgInfo, Subject client,
              Subject server) throws AuthException {
          try {

              String username =
                  processAuthorizationToken(msgInfo, client);
              if (username ==
                  null &#38;&#38; requestPolicy.isMandatory()) {
                  return sendAuthenticateChallenge(msgInfo);
              }

             setAuthenticationResult(
                 username, client, msgInfo);
             return AuthStatus.SUCCESS;

          } catch (Exception e) {
              AuthException ae = new AuthException();
              ae.initCause(e);
              throw ae;
          }
      }

      private String processAuthorizationToken(
              MessageInfo msgInfo, Subject s)
              throws AuthException {

          HttpServletRequest request =
                  (HttpServletRequest)
                  msgInfo.getRequestMessage();

          String token =
                  request.getHeader(AUTHORIZATION_HEADER);

          if (token != null &#38;&#38; token.startsWith(BASIC + " ")) {

              token = token.substring(6).trim();

              // Decode and parse the authorization token
              String decoded =
                  new String(Base64.decode(token.getBytes()));

              int colon = decoded.indexOf(':');
              if (colon &#60;= 0 || colon == decoded.length() - 1) {
                  return (null);
              }

              String username = decoded.substring(0, colon);

             // use the callback to ask the container to
             // validate the password
            PasswordValidationCallback pVC =
                    new PasswordValidationCallback(s, username,
                    decoded.substring(colon + 1).toCharArray());
            try {
                handler.handle(new Callback[]{pVC});
                pVC.clearPassword();
            } catch (Exception e) {
                AuthException ae = new AuthException();
                ae.initCause(e);
                throw ae;
            }

            if (pVC.getResult()) {
                return username;
            }
      }
      return null;
   }

   private AuthStatus sendAuthenticateChallenge(
           MessageInfo msgInfo) {

       String realm = realmName;
         // if the realm property is set use it,
         // otherwise use the name of the server
         // as the realm name.
         if (realm == null) {

          HttpServletRequest request =
                  (HttpServletRequest)
                  msgInfo.getRequestMessage();

          realm = request.getServerName();
        }

       HttpServletResponse response =
               (HttpServletResponse)
               msgInfo.getResponseMessage();

       String header = BASIC + " realm=\"" + realm + "\"";
       response.setHeader(AUTHENTICATION_HEADER, header);
       response.setStatus(
               HttpServletResponse.SC_UNAUTHORIZED);
       return AuthStatus.SEND_CONTINUE;
   }

   public AuthStatus secureResponse(
           MessageInfo msgInfo, Subject service)
           throws AuthException {
       return AuthStatus.SEND_SUCCESS;
   }

   public void cleanSubject(MessageInfo msgInfo,
           Subject subject)
           throws AuthException {
      if (subject != null) {
          subject.getPrincipals().clear();
      }
   }

   private static final String AUTH_TYPE_INFO_KEY =
           "javax.servlet.http.authType";

   // distinguish the caller principal
   // and assign default groups
   private void setAuthenticationResult(String name,
           Subject s, MessageInfo m)
           throws IOException,
           UnsupportedCallbackException {
       handler.handle(new Callback[]{
           new CallerPrincipalCallback(s, name)
       });
       if (name != null) {
         // add the default group if the property is set
           if (defaultGroup != null) {
               handler.handle(new Callback[]{
                   new GroupPrincipalCallback(s, defaultGroup)
               });
           }
           m.getMap().put(AUTH_TYPE_INFO_KEY, ""MySAM");
       }
   }
  }</pre><p>Note that the <tt>initialize</tt> method looks for the <tt>group.name</tt> and <tt>realm.name</tt> properties. The <tt>group.name</tt>
property configures the default group assigned as a result of any successful authentication.
The <tt>realm.name</tt> property defines the realm value sent back to the browser in
the <tt>WWW-Authenticate</tt> challenge.</p>

<a name="gizfa"></a><h4>Compiling and Installing a Server Authentication Module</h4>
<p>Before you can use the sample SAM, you need to compile, install, and
configure it. Then you can bind it to an application.</p><p>To compile the SAM, include the SPI in your classpath. When the Enterprise
Server is installed, the JAR file containing the SPI, <tt>jmac-api.jar</tt>, is installed
in the <i>as-install</i><tt>/lib</tt> directory. After you compile the SAM, install it by copying
a JAR file containing the compiled SAM to the <i>as-install</i><tt>/lib</tt> directory.</p>

<a name="gizfe"></a><h4>Configuring a Server Authentication Module</h4>
<p>You can configure a SAM in one of these ways:</p>
<ul><li><p><a name="indexterm-338"></a>In the Administration Console, open the Security component under the relevant configuration and go to the Message Security page. Set the following options:</p>
<ul><li><p>Authentication Layer &#8212; <tt>HttpServlet</tt></p></li>
<li><p>Provider Type &#8212; <tt>server</tt> or <tt>client-server</tt></p></li>
<li><p>Provider ID &#8212; Specify a unique name for the SAM, for example <tt>MySAM</tt></p></li>
<li><p>Class Name &#8212; Specify the fully qualified class name, for example <tt>tip.sam.MySam</tt></p></li>
<li><p>Additional Property &#8212; Name: <tt>group-name</tt> Value: <tt>user</tt></p></li>
<li><p>Additional Property &#8212; Name: <tt>realm-name</tt> Value: <tt>Sam</tt></p></li></ul>
<p>For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-339"></a><a name="indexterm-340"></a>Use the <tt>asadmin create-message-security-provider</tt> command to configure a SAM. Set the following options:</p>
<ul><li><p><tt>--layer HttpServlet</tt></p></li>
<li><p><tt>--providertype server</tt> or <tt>--providertype client-server</tt></p></li>
<li><p><tt>--classname tip.sam.MySam</tt></p></li>
<li><p><tt>--property group-name=user:realm-name=Sam</tt></p></li>
<li><p>Provider name operand &#8212; Specify a unique name for the SAM, for example <tt>MySAM</tt></p></li></ul>
<p>For details, see the <a href="http://docs.sun.com/doc/820-7701"><i>Sun GlassFish Enterprise Server v3 Reference Manual</i></a>.</p></li></ul>


<a name="gizfm"></a><h4>Binding a Server Authentication Module to Your Application</h4>
<p>After you install and configure the SAM, you can bind it for use
by the container on behalf of one or more of your applications. You
have two options in how you bind the SAM, depending on whether you
are willing to repackage and redeploy your application:</p>
<ul><li><p>If you are willing to repackage and redeploy, you can bind the SAM using the <tt>sun-web.xml</tt> file. Set the value of the <tt>httpservlet-security-provider</tt> attribute of the <tt>sun-web-app</tt> element to the SAM's configured provider ID, for example, <tt>MySAM</tt>. For more information about the <tt>sun-web.xml</tt> file, see the <a href="http://docs.sun.com/doc/820-7693"><i>Application Deployment Guide</i></a>. This option leverages the native <tt>AuthConfigProvider</tt> implementation that ships with the Enterprise Server.</p></li>
<li><p>Another approach is to develop your own <tt>AuthConfigProvider</tt> and register it with the Enterprise Server <tt>AuthConfigFactory</tt> for use on behalf of your applications. For example, a simple <tt>AuthConfigProvider</tt> can obtain, through its initialization properties, the classname of a SAM to configure on behalf of the applications for which the provider is registered. You can find a description of the functionality of an <tt>AuthConfigProvider</tt> and of the registration facilities provided by an <tt>AuthConfigFactory</tt> in the JSR 196 specification.</p></li></ul>



<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p9.html">Previous</a></td>
<td></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p11.html">Next</a></td>
</tr>
</table>



</body>
</html>

