<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8">
<title>Configuring Security - Sun GlassFish Enterprise Server 2.1 Administration Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-12-01">
</head>

<body>


<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&#160;</td>
<td><a href="p11.html">Previous</a></td>
<td></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p13.html">Next</a></td>
</tr>
</table>


<a name="ablnk"></a>Chapter&#160;9<h3>Configuring Security</h3><p>Security is about protecting data: how to prevent unauthorized access or damage to
it in storage or transit. The Enterprise Server; has a dynamic, extensible security
architecture based on the Java EE standard. Built in security features include cryptography,
authentication and authorization, and public key infrastructure. The Enterprise Server is built on
the Java security model, which uses a sandbox where applications can run safely,
without potential risk to systems or users. The following topics are discussed:</p>
<ul><li><p><a href="#ablnn">Understanding Application and System Security</a></p></li>
<li><p><a href="#ablno">Tools for Managing Security</a></p></li>
<li><p><a href="#ablnp">Managing Security of Passwords</a></p></li>
<li><p><a href="#ablnx">About Authentication and Authorization</a></p></li>
<li><p><a href="#abloe">Understanding Users, Groups, Roles, and Realms</a></p></li>
<li><p><a href="#abloj">Introduction to Certificates and SSL</a></p></li>
<li><p><a href="#ablop">About Firewalls</a></p></li>
<li><p><a href="#ablqx">About Certificate Files</a></p></li>
<li><p><a href="#ablqz">Using Java Secure Socket Extension (JSSE) Tools</a></p></li>
<li><p><a href="#ablrf">Using Network Security Services (NSS) Tools</a></p></li>
<li><p><a href="#gcsno">Using Hardware Crypto Accelerator With Enterprise Server</a></p></li></ul>


<a name="ablnn"></a><h3>Understanding Application and System Security</h3>
<p>Broadly, there are two kinds of application security:</p>
<ul><li><p>In <b>programmatic security</b>, application code written by the developer handles security chores. As an administrator, you don't have any control over this mechanism. Generally, programmatic security is discouraged since it hard-codes security configurations in the application instead of managing it through the Java EE containers.</p></li>
<li><p>In <b>declarative security</b>, the container (the Enterprise Server) handles security through an application's deployment descriptors. You can control declarative security by editing deployment descriptors directly or with a tool such as <tt>deploytool</tt>. Because deployment descriptors can change after an application is developed, declarative security allows for more flexibility.</p></li></ul>
<p>In addition to application security, there is also <b>system security</b>, which affects all
the applications on an Enterprise Server system.</p><p>Programmatic security is controlled by the application developer, so this document does not
discuss it; declarative security is somewhat less so, and this document touches on
it occasionally. This document is intended primarily for system administrators, and so focuses
on system security.</p>

<a name="ablno"></a><h3>Tools for Managing Security</h3>
<p>The Enterprise Server provides the following tools for managing security:</p>
<ul><li><p>Admin Console, a browser-based tool used to configure security for the entire server, to manage users, groups, and realms, and to perform other system-wide security tasks. For a general introduction to the Admin Console, see <a href="p4.html#ablav">Tools for Administration</a>. For an overview of the security tasks consult the Admin Console online help.</p></li>
<li><p><tt>asadmin</tt>, a command-line tool that performs many of the same tasks as the Admin Console. You may be able to do some things with <tt>asadmin</tt> that you cannot do with Admin Console. You perform <tt>asadmin</tt> commands from either a command prompt or from a script, to automate repetitive tasks. For a general introduction to <tt>asadmin</tt>, see <a href="p4.html#ablav">Tools for Administration</a>.</p></li></ul>
<p>The Java Platform, Standard Edition (Java SE) provides two tools for managing security:</p>
<ul><li><p><tt>keytool</tt>, a command-line utility for managing digital certificates and key pairs. Use <tt>keytool</tt> to manage users in the <tt>certificate</tt> realm.</p></li>
<li><p><tt>policytool</tt>, a graphical utility for managing system-wide Java security policies. As an administrator, you will rarely need to use <tt>policytool</tt>.</p></li></ul>
<p>For more information on using <tt>keytool</tt>, <tt>policytool</tt>, and other Java security tools,
see<i> JDK Tools and Utilities</i> at <a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security">http://java.sun.com/j2se/1.5.0/docs/tooldocs/#security</a>.</p><p>In the Enterprise Profile, two other tools that implement Network Security Services (NSS)
are available for managing security. For more information on NSS, go to <a href="http://www.mozilla.org/projects/security/pki/nss/">http://www.mozilla.org/projects/security/pki/nss/</a>.
The tools for managing security include the following:</p>
<ul><li><p><tt>certutil</tt>, a command-line utility for managing certificates and key databases.</p></li>
<li><p><tt>pk12util</tt>, a command-line utility used to import and export keys and certificates between the certificate/key databases and files in PKCS12 format.</p></li></ul>
<p>For more information on using <tt>certutil</tt>, <tt>pk12util</tt>, and other NSS security tools,
see<i> NSS Security Tools</i> at <a href="http://www.mozilla.org/projects/security/pki/nss/tools">http://www.mozilla.org/projects/security/pki/nss/tools</a>.</p>

<a name="ablnp"></a><h3>Managing Security of Passwords</h3>
<p>In the Enterprise Server, the file <tt>domain.xml</tt>, which contains the specifications for a
particular domain, initially contains the password of the Message Queue broker in clear
text. The element in the <tt>domain.xml</tt> file that contains this password is
the <tt>admin-password</tt> attribute of the <tt>jms-host</tt> element. Because this password is not changeable at
installation time, it is not a significant security impact.</p><p>However, use the Admin Console to add users and resources and assign passwords
to these users and resources. Some of these passwords are written to the
<tt>domain.xml</tt> file in clear text, for example, passwords for accessing a database. Having
these passwords in clear text in the <tt>domain.xml</tt> file can present a
security hazard. You can encrypt any password in <tt>domain.xml</tt>, including the <tt>admin-password</tt> attribute or
a database password. Instructions for managing the security passwords is included in the
following topics:</p>
<ul><li><p><a href="#gdhsj">Encrypting a Password in the <tt>domain.xml</tt> File</a></p></li>
<li><p><a href="#ablnq">Protecting Files with Encoded Passwords</a></p></li>
<li><p><a href="#gdhsn">Changing the Master Password</a></p></li>
<li><p><a href="#gczen">Working with the Master Password and Keystores</a></p></li>
<li><p><a href="#gdhth">Changing the Admin Password</a></p></li></ul>


<a name="gdhsj"></a><h4>Encrypting a Password in the <tt>domain.xml</tt> File</h4>
<p>To encrypt a password in the <tt>domain.xml</tt> file. Follow these steps:</p>
<ol><li><p>From the directory where the <tt>domain.xml</tt> file resides (<i>domain-dir</i><tt>/config</tt> by default), run the following <tt>asadmin</tt> command:</p><pre>asadmin create-password-alias --user admin <i>alias-name</i></pre><p>For example,</p><pre>asadmin create-password-alias --user admin jms-password</pre><p>A password prompt appears (<tt>admin</tt> in this case). Refer to the man pages for the <tt>create-password-alias</tt>, <tt>list-password-aliases</tt>, <tt>delete-password-alias</tt> commands for more information.</p></li>
<li><p>Remove and replace the password in <tt>domain.xml</tt>. This is accomplished using the <tt>asadmin set</tt> command. An example of using the <tt>set</tt> command for this purpose is as follows:</p><pre>asadmin set --user admin server.jms-service.jms-host.
default_JMS_host.admin-password='${ALIAS=jms-password}'</pre>
<hr><p><b>Note - </b>Enclose the alias password in single quotes as shown in the example. </p>
<hr>
</li>
<li><p>Restart the Enterprise Server for the relevant domain.</p></li></ol>


<a name="ablnq"></a><h4>Protecting Files with Encoded Passwords</h4>
<p>Some files contain encoded passwords that need protecting using file system permissions. These
files include the following:</p>
<ul><li><p><i>domain-dir</i><tt>/master-password</tt></p><p>This file contains the encoded master password and should be protected with file system permissions 600.</p></li>
<li><p>Any password file created to pass as an argument using the <tt>--passwordfile</tt> argument to <tt>asadmin</tt> should be protected with file system permissions 600.</p></li></ul>


<a name="gdhsn"></a><h4>Changing the Master Password</h4>
<p>The master password (MP) is an overall shared password. It is never used
for authentication and is never transmitted over the network. This password is the
central point for overall security; the user can choose to enter it manually
when required, or obscure it in a file. It is the most
sensitive piece of data in the system. The user can force prompting for
the master password by removing this file. When the master password is changed,
it is re-saved in the master-password keystore, which is a Java JCEKS type
keystore.</p><p>To change the master password, follow these steps:</p>
<ol><li><p>Stop the Enterprise Server for the domain. Use the <tt>asadmin change-master-password</tt> command, which prompts for the old and new passwords, then re-encrypts all dependent items. For example:</p><pre>asadmin change-master-password>
Please enter the master password>
Please enter the new master password>
Please enter the the new master password again></pre></li>
<li><p>Restart the Enterprise Server.</p>
<hr><p><b>Caution - </b>At this point in time, server instances that are running must not be started and running server instances must not be restarted until the SMP on their corresponding node agent has been changed. If a server instance is restarted before changing its SMP, it will fail to come up.</p>
<hr>
</li>
<li><p>Stop each node agent and its related servers one at a time. Run the <tt>asadmin change-master-password</tt> command again, and then restart the node agent and its related servers.</p></li>
<li><p>Continue with the next node agent until all node agents have been addressed. In this way, a rolling change is accomplished.</p></li></ol>


<a name="gczen"></a><h4>Working with the Master Password and Keystores</h4>
<p>The master password is the password for the secure keystore . When
a new application server domain is created, a new self-signed certificate is generated and
stored in the relevant keystore, which is locked using the master password. If
the master password is not the default, the <tt>start-domain</tt> command prompts you for
the master password. Once the correct master password is entered, the domain starts.
</p><p>When a node agent associated with the domain is created, the node
agent synchronizes the data with domain. While doing so, the keystore is also
synchronized. Any server instance controlled by this node agent needs to open the
keystore. Since the store is essentially identical to the store that was created
by the domain creation process, it can only be opened by an identical
master password. But the master password itself is never  synchronized, meaning it is
not transmitted to the node agent during the  synchronization, but needs to
be available with the node agent locally. This is why  creation
and/or starting of a node agent prompts you for the master password and
 you need to enter the same password that you entered while 
creating/starting the domain. If the master password is changed for a domain, you
will have to perform  the same step to change it at every
node agent that is associated with this  domain.</p>

<a name="gdhth"></a><h4>Changing the Admin Password</h4>
<p>Encrypting the admin password is discussed in <a href="#ablnp">Managing Security of Passwords</a>. Encrypting the admin password
is strongly encouraged. If you want to change the admin password before encrypting
it, use the <tt>change-admin-password</tt> command. </p><p>Consult the Admin Console online help for instructions on changing the admin password
using the Admin Console.</p>

<a name="ablnx"></a><h3>About Authentication and Authorization</h3>
<p>Authentication and authorization are central concepts of application server security. The following topics
are discussed related to authentication and authorization:</p>
<ul><li><p><a href="#ablny">Authenticating Entities</a></p></li>
<li><p><a href="#abloa">Authorizing Users</a></p></li>
<li><p><a href="#ablob">Specifying JACC Providers</a></p></li>
<li><p><a href="#abloc">Auditing Authentication and Authorization Decisions</a></p></li>
<li><p><a href="#ablod">Configuring Message Security</a></p></li></ul>


<a name="ablny"></a><h4>Authenticating Entities</h4>
<p><b>Authentication</b> is the way an entity (a user, an application, or a component)
determines that another entity is who it claims to be. An entity uses
<b>security credentials</b> to authenticate itself. The credentials may be a user name and password,
a digital certificate, or something else.</p><p>Typically, authentication means a user logging in to an application with a user
name and password; but it might also refer to an EJB providing security
credentials when it requests a resource from the server. Usually, servers or applications
require clients to authenticate; additionally, clients can require servers to authenticate themselves, too.
When authentication is bidirectional, it is called mutual authentication.</p><p>When an entity tries to access a protected resource, the Enterprise Server
uses the authentication mechanism configured for that resource to determine whether to grant access.
For example, a user can enter a user name and password in a
Web browser, and if the application verifies those credentials, the user is authenticated.
The user is associated with this authenticated security identity for the remainder of
the session.</p><p>The Enterprise Server supports four types of authentication. An application specifies the type
of authentication it uses within its deployment descriptors. </p><a name="gdhgx"></a><h6>Table&#160;9-1 Enterprise Server Authentication Methods</h6><table><col width="25%"><col width="25%"><col width="25%"><col width="25%"><tr><td align="left" valign="top" scope="row"><p><b>Authentication Method</b></p></td>
<td align="left" valign="top" scope="row"><p><b>Communication Protocol</b></p></td>
<td align="left" valign="top" scope="row"><p><b>Description</b></p></td>
<td align="left" valign="top" scope="row"><p><b>User Credential Encryption</b></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>BASIC</p></td>
<td align="left" valign="top" scope="row"><p>HTTP (SSL optional)</p></td>
<td align="left" valign="top" scope="row"><p>Uses the
server's built-in pop-up login dialog box.</p></td>
<td align="left" valign="top" scope="row"><p>None, unless using SSL.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>FORM</p></td>
<td align="left" valign="top" scope="row"><p>HTTP (SSL optional)</p></td>
<td align="left" valign="top" scope="row"><p>Application provides
its own custom login and error pages.</p></td>
<td align="left" valign="top" scope="row"><p>None, unless using SSL.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>CLIENT-CERT</p></td>
<td align="left" valign="top" scope="row"><p>HTTPS (HTTP over
SSL)</p></td>
<td align="left" valign="top" scope="row"><p>Server authenticates the client using a public key certificate.</p></td>
<td align="left" valign="top" scope="row"><p>SSL</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>DIGEST</p></td>
<td align="left" valign="top" scope="row"><p>HTTP and SIP</p></td>
<td align="left" valign="top" scope="row"><p>Server authenticates
the client based on an encrypted response.</p></td>
<td align="left" valign="top" scope="row"><p>SSL and TLS</p></td>
</tr>
</table>

<a name="ablnz"></a><h5>Verifying Single Sign-On</h5>
<p>Single sign-on enables multiple applications in one virtual server instance to share the
user authentication state. With single sign-on, a user who logs in to one
application becomes implicitly logged in to other applications that require the same authentication
information.</p><p>Single sign-on is based on groups. All Web applications whose deployment descriptor defines
the same <b>group</b> and use the same authentication method (BASIC, FORM, CLIENT-CERT) share
single sign-on.</p><p>Single sign-on is enabled by default for virtual servers defined for the Enterprise
Server.</p>

<a name="abloa"></a><h4>Authorizing Users</h4>
<p>Once a user is authenticated, the level of <b>authorization</b> determines what operations can
be performed. A user's authorization is based on his <b>role</b>. For example,
a human resources application may authorize managers to view personal employee information for
all employees, but allow employees to view only their own personal information. For
more on roles, see <a href="#abloe">Understanding Users, Groups, Roles, and Realms</a>.</p>

<a name="ablob"></a><h4>Specifying JACC Providers</h4>
<p>JACC (Java Authorization Contract for Containers) is part of the Java EE specification
that defines an interface for pluggable authorization providers. This enables the administrator to
set up third-party plug-in modules to perform authorization.</p><p>By default, the Enterprise Server provides a simple, file-based authorization engine that complies
with the JACC specification. It is also possible to specify additional third-party JACC
providers.</p><p>JACC providers use the Java Authentication and Authorization Service (JAAS) APIs. JAAS enables
services to authenticate and enforce access controls upon users. It implements a Java
technology version of the standard Pluggable Authentication Module (PAM) framework.</p>

<a name="abloc"></a><h4>Auditing Authentication and Authorization Decisions</h4>
<p>The Enterprise Server can provide an audit trail of all authentication and authorization
decisions through <b>audit modules</b>. The Enterprise Server provides a default audit module, as well
as the ability to customize the audit modules.</p>

<a name="ablod"></a><h4>Configuring Message Security</h4>
<p><b>Message Security</b> enables a server to perform end-to-end authentication of web service invocations and
responses at the message layer. The Enterprise Server implements message security using message
security providers on the SOAP layer. The message security providers provide information such as
the type of authentication that is required for the request and response messages.
The types of authentication that are supported include the following:</p>
<ul><li><p>Sender authentication, including username-password authentication.</p></li>
<li><p>Content authentication, including XML Digital Signatures.</p></li></ul>
<p>Two message security providers are included with this release. The message security providers
can be configured for authentication for the SOAP layer. The providers that can
be configured include <tt>ClientProvider</tt> and <tt>ServerProvider</tt>.</p><p>Support for message layer security is integrated into the Enterprise Server and its
client containers in the form of (pluggable) authentication modules. By default, message layer
security is disabled on the Enterprise Server.</p><p>Message level security can be configured for the entire Enterprise Server or for
specific applications or methods. Configuring message security at the Enterprise Server level is
discussed in <a href="p13.html">Chapter&#160;10, Configuring Message Security</a>. Configuring message security at the application level is discussed in
the <b>Developer's Guide</b>.</p>

<a name="abloe"></a><h3>Understanding Users, Groups, Roles, and Realms</h3>
<p>The Enterprise Server enforces its authentication and authorization policies upon the following entities:</p>
<ul><li><p><a href="#ablof">Users</a>: An individual identity <b>defined in the Enterprise Server</b>. In general, a user is a person, a software component such as an enterprise bean, or even a service. A user who has been authenticated is sometimes called a <b>principal</b>. Users are sometimes referred to as <b>subjects</b>.</p></li>
<li><p><a href="#ablog">Groups</a>: A set of users <b>defined in the Enterprise Server</b>, classified by common traits.</p></li>
<li><p><a href="#abloh">Roles</a>: A named authorization level <b>defined by an application</b>. A role can be compared to a key that opens a lock. Many people might have a copy of the key. The lock doesn't care who seeks access, only that the right key is used.</p></li>
<li><p><a href="#abloi">Realms</a>: A repository containing user and group information and their associated security credentials. A realm is also called a <b>security policy domain</b>.</p></li></ul>

<hr><p><b>Note - </b>Users and groups are designated for the entire Enterprise Server, whereas each application
defines its own roles. When the application is being packaged and deployed, the
application specifies mappings between users/groups and roles, as illustrated in the following figure.</p>
<hr>
<a name="fxjfw"></a><h6>Figure&#160;9-1 Role Mapping</h6><img src="figures/security-roleMapping.gif" alt="Figure shows how users are assigned to groups, how users and groups are assigned to roles, and how applications use groups and roles." width="440" height="228"></img>

<a name="ablof"></a><h4>Users</h4>
<p>A <b>user</b> is an individual (or application program) identity that has been defined
in the Enterprise Server. A user can be associated with a group. The
Enterprise Server authentication service can govern users in multiple realms.</p>

<a name="ablog"></a><h4>Groups</h4>
<p>A <b>Java EE group</b> (or simply group) is a category of users classified by common
traits, such as job title or customer profile. For example, users of an
e-commerce application might belong to the <tt>customer</tt> group, but the big spenders
would belong to the <tt>preferred</tt> group. Categorizing users into groups makes it easier
to control the access of large numbers of users.</p>

<a name="abloh"></a><h4>Roles</h4>
<p>A <b>role</b> defines which applications and what parts of each application users can
access and what they can do. In other words, roles determine users' authorization
levels.</p><p>For example, in a personnel application all employees might have access to phone
numbers and email addresses, but only managers would have access to salary information.
The application might define at least two roles: <tt>employee</tt> and <tt>manager</tt>; only
users in the <tt>manager</tt> role are allowed to view salary information.</p><p>A role is different from a user group in that a role
defines a function in an application, while a group is a set of
users who are related in some way. For example, in the personnel application
there might be groups such as <tt>full-time</tt>, <tt>part-time</tt>, and <tt>on-leave</tt>, but users in
all these groups would still be in the <tt>employee</tt> role.</p><p>Roles are defined in application deployment descriptors. In contrast, groups are defined for
an entire server and realm. The application developer or deployer maps roles to
one or more groups for each application in its deployment descriptor.</p>

<a name="abloi"></a><h4>Realms</h4>
<p>A <b>realm</b>, also called a <b>security policy domain</b> or <b>security domain</b>, is a scope over which
the server defines and enforces a common security policy. In practical terms, a
realm is a repository where the server stores user and group information.</p><p>The Enterprise Server comes preconfigured with three realms: <tt>file</tt> (the initial default realm),
<tt>certificate</tt>, and <tt>admin-realm</tt>. It is possible to also set up <tt>ldap</tt>, <tt>JDBC</tt>, <tt>solaris</tt>,
or custom realms. Applications can specify the realm to use in their deployment
descriptor. If they do not specify a realm, the Enterprise Server uses its
default realm.</p><p>In the <tt>file</tt> realm, the server stores user credentials locally in a file
named <tt>keyfile</tt>. You can use the Admin Console to manage users in the
<tt>file</tt> realm.</p><p>In the <tt>certificate</tt> realm, the server stores user credentials in a certificate database.
When using the <tt>certificate</tt> realm, the server uses certificates with the HTTPS protocol
to authenticate Web clients. For more information about certificates, see <a href="#abloj">Introduction to Certificates and SSL</a>.</p><p>The <tt>admin-realm</tt> is also a <tt>FileRealm</tt> and stores administrator user credentials locally in
a file named <tt>admin-keyfile</tt>. Use the Admin Console to manage users in
this realm in the same way you manage users in the <tt>file</tt> realm.</p><p>In the <tt>ldap</tt> realm the server gets user credentials from a Lightweight Directory
Access Protocol (LDAP) server such as the Directory Server. LDAP is a protocol
for enabling anyone to locate organizations, individuals, and other resources such as files
and devices in a network, whether on the public Internet or on a
corporate intranet. Consult your LDAP server documentation for information on managing users and
groups in the <tt>ldap</tt> realm.</p><p>In the <tt>JDBC</tt> realm, the server gets user credentials from a database. The
Enterprise Server uses the database information and the enabled JDBC realm option in
the configuration file. For digest authentication, a <tt>JDBC</tt> realm should be created
with <tt>jdbcDigestRealm</tt> as the JAAS context. </p><p>In the <tt>solaris</tt> realm the server gets user credentials from the Solaris operating
system. This realm is supported on the Solaris 9 OS and later. Consult
your Solaris documentation for information on managing users and groups in the <tt>solaris</tt>
realm.</p><p>A custom realm is any other repository of user credentials, such as a
relational database or third-party component. For more information, see the Admin Console online
help.</p>

<a name="gfzkj"></a><h5>To Configure a <tt>JDBC</tt> Realm for a Web, EJB Application</h5>
<p>The Enterprise Server enables you to specify a user's credentials in the
<tt>JDBC</tt> realm instead of in the connection pool. Using the <tt>JDBC</tt> realm instead
of the connection pool prevents other applications from browsing the database tables for
the user's credentials. A user's credentials are the user's name and password.</p>
<hr><p><b>Note - </b>By default, storage of passwords as clear text is not supported in the
<tt>JDBC</tt> realm. Under normal circumstances, passwords should not be stored as clear text.</p>
<hr>
<ol>
<li><a name="gfzjl"></a><b>Create the database tables in which to store the users' credentials for the
realm.</b><p>How to create the database tables depends on the database that you are
using.</p></li>
<li><b>Add the users' credentials to the  database tables that you created in
<a href="#gfzjl">Step&#160;1</a>.</b><p>How to add users' credentials to the database tables depends on the database
that you are using.</p></li>
<li><a name="gfzkf"></a><b>Create a <tt>JDBC</tt> realm.</b><p>Use the Admin Console GUI for this purpose. For instructions for creating a
<tt>JDBC</tt> realm, see the online help for the Admin Console GUI.</p></li>
<li><a name="gfzmg"></a><b>Specify the realm that you created in <a href="#gfzkf">Step&#160;3</a> as the realm for
the application.</b><p>To specify the realm, modify the appropriate deployment descriptor for your application:</p><ul>
<li><b>For an enterprise application in an Enterprise Archive (EAR) file, modify the <tt>sun-application.xml</tt>
file.</b></li>
<li><b>For a web application in a Web Application Archive (WAR) file, modify the
<tt>web.xml</tt> file.</b></li>
<li><b>For an enterprise bean in an EJB JAR file, modify the <tt>sun-ejb-jar.xml</tt>
 file.</b></li></ul><p>For more information about how to specify a realm, see <a href="http://docs.sun.com/doc/820-4336/beabr?a=view">How to Set a Realm for an Application or Module in <i>Sun GlassFish Enterprise Server 2.1 Developer&#8217;s Guide</i></a>.</p></li>
<li><b>Assign a security role to users in the realm.</b><p>To assign a security role to a user, add a <tt>security-role-mapping</tt> element to the
deployment descriptor that you modified in <a href="#gfzmg">Step&#160;4</a>.</p><p>The following example shows a <tt>security-role-mapping</tt> element that assigns the security role
<tt>Employee</tt> to user <tt>Calvin</tt>.</p><pre>&#60;security-role-mapping>
    &#60;role-name>Employee&#60;/role-name>
    &#60;principal-name>Calvin&#60;/principal-name>
  &#60;/security-role-mapping></pre></li></ol>

<a name="abloj"></a><h3>Introduction to Certificates and SSL</h3>
<p>The following topics are discussed in this section:</p>
<ul><li><p><a href="#ablok">About Digital Certificates</a></p></li>
<li><p><a href="#ablom">About Secure Sockets Layer</a></p></li></ul>


<a name="ablok"></a><h4>About Digital Certificates</h4>
<p><b>Digital certificates</b> (or simply certificates) are electronic files that uniquely identify people and resources
on the Internet. Certificates also enable secure, confidential communication between two entities.</p><p>There are different kinds of certificates, such as personal certificates, used by individuals,
and server certificates, used to establish secure sessions between the server and clients
through secure sockets layer (SSL) technology. For more information on SSL, see <a href="#ablom">About Secure Sockets Layer</a>.</p><p>Certificates are based on <b>public key cryptography</b>, which uses pairs of digital <b>keys</b> (very long
numbers) to <b>encrypt</b>, or encode, information so it can be read only by its
intended recipient. The recipient then <b>decrypts</b> (decodes) the information to read it.</p><p>A key pair contains a public key and a private key. The
owner distributes the public key and makes it available to anyone. But the
owner never distributes the private key; it is always kept secret. Because the
keys are mathematically related, data encrypted with one key can be decrypted only
with the other key in the pair.</p><p>A certificate is like a passport: it identifies the holder and provides other
important information. Certificates are issued by a trusted third party called a <b>Certification Authority</b>
(CA). The CA is analogous to passport office: it validates the certificate holder's
identity and signs the certificate so that it cannot be forged or tampered
with. Once a CA has signed a certificate, the holder can present it
as proof of identity and to establish encrypted, confidential communications.</p><p>Most importantly, a certificate binds the owner's public key to the owner's identity.
Like a passport binds a photograph to personal information about its holder, a
certificate binds a public key to information about its owner.</p><p>In addition to the public key, a certificate typically includes information such as:</p>
<ul><li><p>The name of the holder and other identification, such as the URL of the Web server using the certificate, or an individual's email address.</p></li>
<li><p>The name of the CA that issued the certificate.</p></li>
<li><p>An expiration date.</p></li></ul>
<p>Digital Certificates are governed by the technical specifications of the X.509 format. To
verify the identity of a user in the <a name="indexterm-88"></a><tt>certificate</tt> realm, the authentication service
verifies an X.509 certificate, using the common name field of the X.509 certificate
as the principal name.</p>

<a name="ablol"></a><h5>About Certificate Chains</h5>
<p>Web browsers are preconfigured with a set of <b>root</b> CA certificates that the
browser automatically trusts. Any certificates from elsewhere must come with a <b>certificate chain</b> to
verify their validity. A certificate chain is series of certificates issued by successive CA
certificates, eventually ending in a root CA certificate.</p><p>When a certificate is first generated, it is a <b>self-signed</b> certificate. A self-signed
certificate is one for which the issuer (signer) is the same as the
subject (the entity whose public key is being authenticated by the certificate). When
the owner sends a certificate signing request (CSR) to a CA, then imports
the response, the self-signed certificate is replaced by a chain of certificates. At
the bottom of the chain is the certificate (reply) issued by the CA
authenticating the subject's public key. The next certificate in the chain is one
that authenticates the CA's public key. Usually, this is a self-signed certificate (that
is, a certificate from the CA authenticating its own public key) and the
last certificate in the chain.</p><p>In other cases, the CA can return a chain of certificates. In
this case, the bottom certificate in the chain is the same (a certificate
signed by the CA, authenticating the public key of the key entry), but
the second certificate in the chain is a certificate signed by a different
CA, authenticating the public key of the CA to which you sent the
CSR. Then, the next certificate in the chain is a certificate authenticating the
second CA's key, and so on, until a self-signed <b>root</b> certificate is reached.
Each certificate in the chain (after the first) thus authenticates the public key of
the signer of the previous certificate in the chain.</p>

<a name="ablom"></a><h4>About Secure Sockets Layer</h4>
<p><b>Secure Sockets Layer</b> (SSL) is the most popular standard for securing Internet communications and transactions.
Web applications use HTTPS (HTTP over SSL), which uses digital certificates to ensure
secure, confidential communications between server and clients. In an SSL connection, both the client
and the server encrypt data before sending it, then decrypt it upon receipt.</p><p>When a Web browser (client) wants to connect to a secure site,
an <b>SSL handshake</b> happens:</p>
<ul><li><p>The browser sends a message over the network requesting a secure session (typically, by requesting a URL that begins with <tt>https</tt> instead of <tt>http</tt>).</p></li>
<li><p>The server responds by sending its certificate (including its public key).</p></li>
<li><p>The browser verifies that the server's certificate is valid and is signed by a CA whose certificate is in the browser's database (and who is trusted). It also verifies that the CA certificate has not expired.</p></li>
<li><p>If the certificate is valid, the browser generates a one time, unique <b>session</b> <b>key</b> and encrypts it with the server's public key. The browser then sends the encrypted session key to the server so that they both have a copy.</p></li>
<li><p>The server decrypts the message using its private key and recovers the session key.</p></li></ul>
<p>After the handshake, the client has verified the identity of the Web site,
and only the client and the Web server have a copy of
the session key. From this point forward, the client and the server use
the session key to encrypt all their communications with each other. Thus, their
communications are ensured to be secure.</p><p>The newest version of the SSL standard is called TLS (Transport Layer Security).
The Enterprise Server supports the Secure Sockets Layer (SSL) 3.0 and the Transport
Layer Security (TLS) 1.0 encryption protocols.</p><p>To use SSL, the Enterprise Server must have a certificate for each
external interface, or IP address, that accepts secure connections. The HTTPS service of most
Web servers will not run unless a digital certificate has been installed. Use
the procedure described in <a href="#ablrb">Generating a Certificate Using the <tt>keytool</tt> Utility</a> to set up a digital certificate that
your Web server can use for SSL.</p>

<a name="ablon"></a><h5>About Ciphers</h5>
<p>A <b>cipher</b> is a cryptographic algorithm used for encryption or decryption. SSL and
TLS protocols support a variety of ciphers used to authenticate the server and
client to each other, transmit certificates, and establish session keys.</p><p>Some ciphers are stronger and more secure than others. Clients and servers can
support different cipher suites. Choose ciphers from the SSL3 and TLS protocols. During
a secure connection, the client and the server agree to use the strongest
cipher they both have enabled for communication, so it is usually sufficient to
enable all ciphers.</p>

<a name="abloo"></a><h5>Using Name-based Virtual Hosts</h5>
<p>Using name-based virtual hosts for a secure application can be problematic. This is
a design limitation of the SSL protocol itself. The SSL handshake, where the
client browser accepts the server certificate, must occur before the HTTP request is
accessed. As a result, the request information containing the virtual host name cannot
be determined prior to authentication, and it is therefore not possible to assign
multiple certificates to a single IP address.</p><p>If all virtual hosts on a single IP address need to authenticate
against the same certificate, the addition of multiple virtual hosts probably will not interfere
with normal SSL operations on the server. Be aware, however, that most browsers
will compare the server's domain name against the domain name listed in the
certificate, if any (applicable primarily to official, CA-signed certificates). If the domain names
do not match, these browsers display a warning. In general, only address-based virtual
hosts are commonly used with SSL in a production environment.</p>

<a name="ablop"></a><h3>About Firewalls</h3>
<p>A <b>firewall</b> controls the flow of data between two or more networks, and
manages the links between the networks. A firewall can consist of both hardware
and software elements. This section describes some common firewall architectures and their configuration.
The information here pertains primarily to the Enterprise Server. For details about a
specific firewall technology, refer to the documentation from your firewall vendor.</p><p>In general, configure the firewalls so that clients can access the necessary TCP/IP
ports. For example, if the HTTP listener is operating on port 8080, configure
the firewall to allow HTTP requests on port 8080 only. Likewise, if HTTPS
requests are setup for port 8181, you must configure the firewalls to allow
HTTPS requests on port 8181.</p><p>If direct Remote Method Invocations over Internet Inter-ORB Protocol (RMI-IIOP) access from the
Internet to EJB modules are required, open the RMI-IIOP listener port as well,
but this is strongly discouraged because it creates security risks.</p><p>In double firewall architecture, you must configure the outer firewall to allow for
HTTP and HTTPS transactions. You must configure the inner firewall to allow the
HTTP server plug-in to communicate with the Enterprise Server behind the firewall.</p>

<a name="ablqx"></a><h3>About Certificate Files</h3>
<p>Installation of the Enterprise Server generates a digital certificate in JSSE (Java Secure
Socket Extension) or NSS (Network Security Services) format suitable for internal testing. By
default, the Enterprise Server stores its certificate information in a certificate database in
the <i>domain-dir</i><tt>/config</tt> directory:</p>
<ul><li><p><b>Keystore file</b>, <tt>key3.db</tt>, contains the Enterprise Server's certificate, including its private key. The keystore file is protected with a password. Change the password using the <tt>asadmin change-master-password</tt> command.</p><p>Each keystore entry has a unique alias. After installation, the Enterprise Server keystore has a single entry with alias <tt>s1as</tt>.</p></li>
<li><p><b>Truststore file</b>, <tt>cert8.db</tt>, contains the Enterprise Server's trusted certificates, including public keys for other entities. For a trusted certificate, the server has confirmed that the public key in the certificate belongs to the certificate's owner. Trusted certificates generally include those of certification authorities (CAs).</p><p>In the Developer Profile, on the server side, the Enterprise Server uses the JSSE format, which uses <tt>keytool</tt> to manage certificates and key stores. In the Clusters and Enterprise Profile, on the server side, the Enterprise Server uses NSS, which uses <tt>certutil</tt> to manage the NSS database which stores private keys and certificates. In both profiles, the client side (appclient or stand-alone), uses the JSSE format.</p><p>By default, the Enterprise Server is configured with a keystore and truststore that will work with the example applications and for development purposes. For production purposes, you may wish to change the certificate alias, add other certificates to the truststore, or change the name and/or location of the keystore and truststore files.</p></li></ul>


<a name="gdhwg"></a><h4>Changing the Location of Certificate Files</h4>
<a name="indexterm-89"></a><a name="indexterm-90"></a><p>The keystore and truststore files provided for development are stored in the <i>domain-dir</i><tt>/config</tt>
directory.</p><p>Use the Admin Console to add or modify the value field for
the new location of the certificate files.</p><pre>-Dcom.sun.appserv.nss.db=${com.sun.aas.instanceRoot}/<i>NSS-database-directory</i></pre><p>where <i>NSS-database-directory</i> is the location of the NSS database.</p>

<a name="ablqz"></a><h3>Using Java Secure Socket Extension (JSSE) Tools</h3>
<p>Use <tt>keytool</tt> to set up and work with JSSE (Java Secure Socket Extension)
digital certificates. In the Developer Profile, the Enterprise Server uses the JSSE format
on the server side to manage certificates and key stores. In all the
profiles, the client side (appclient or stand-alone) uses the JSSE format.</p><p>The J2SE SDK ships with <tt>keytool</tt>, which enables the administrator to administer public/private
key pairs and associated certificates. It also enables users to cache the public
keys (in the form of certificates) of their communicating peers.</p><p>To run <tt>keytool</tt>, the shell environment must be configured so that the J2SE
<tt>/bin</tt> directory is in the path, or the full path to the tool
must be present on the command line. For more information on <tt>keytool</tt>, see
the <tt>keytool</tt> documentation at <a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html">http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html</a>.</p>

<a name="ablra"></a><h4>Using the keytool Utility</h4>
<p>The following examples demonstrate usage related to certificate handling using JSSE tools:</p>
<ul><li><p>Create a self-signed certificate in a keystore of type JKS using an RSA key algorithm. RSA is public-key encryption technology developed by RSA Data Security, Inc. The acronym stands for Rivest, Shamir, and Adelman, the inventors of the technology.</p><pre>keytool  -genkey -noprompt -trustcacerts -keyalg RSA -alias ${cert.alias} 
-dname  ${dn.name} -keypass ${key.pass} -keystore ${keystore.file} 
-storepass ${keystore.pass}</pre><p>Another example of creating a certificate is shown in <a href="#ablrb">Generating a Certificate Using the <tt>keytool</tt> Utility</a>.</p></li>
<li><p>Create a self-signed certificate in a keystore of type JKS using the default key algorithm.</p><pre>keytool -genkey -noprompt -trustcacerts -alias ${cert.alias} -dname  
${dn.name} -keypass ${key.pass} -keystore ${keystore.file} -storepass 
${keystore.pass}</pre><p>An example of signing a certificate is shown in <a href="#ablrc">Signing a Digital Certificate Using the <tt>keytool</tt> Utility</a></p></li>
<li><p>Display available certificates from a keystore of type JKS.</p><pre>keytool -list -v  -keystore ${keystore.file} -storepass ${keystore.pass}</pre></li>
<li><p>Display certificate information from a keystore of type JKS.</p><pre>keytool -list -v  -alias ${cert.alias} -keystore ${keystore.file} 
-storepass ${keystore.pass}</pre></li>
<li><p>Import an RFC/text-formatted certificate into a JKS store. Certificates are often stored using the printable encoding format defined by the Internet RFC (Request for Comments) 1421 standard instead of their binary encoding. This certificate format, also known as <b>Base 64 encoding</b>, facilitates exporting certificates to other applications by email or through some other mechanism.</p><pre>keytool -import -noprompt -trustcacerts -alias ${cert.alias} -file 
${cert.file} -keystore ${keystore.file} -storepass ${keystore.pass}</pre></li>
<li><p>Export a certificate from a keystore of type JKS in PKCS7 format. The reply format defined by the Public Key Cryptography Standards #7, Cryptographic Message Syntax Standard, includes the supporting certificate chain in addition to the issued certificate.</p><pre>keytool -export -noprompt -alias ${cert.alias} -file ${cert.file} 
-keystore ${keystore.file} -storepass ${keystore.pass}</pre></li>
<li><p>Export a certificate from a keystore of type JKS in RFC/text format.</p><pre>keytool -export -noprompt -rfc -alias ${cert.alias} -file 
${cert.file} -keystore ${keystore.file} -storepass ${keystore.pass}</pre></li>
<li><p>Delete a certificate from a keystore of type JKS.</p><pre>keytool -delete -noprompt -alias ${cert.alias}  -keystore ${keystore.file} 
-storepass ${keystore.pass}</pre><p>Another example of deleting a certificate from a keystore is shown in <a href="#ablre">Deleting a Certificate Using the <tt>keytool</tt> Utility</a></p></li></ul>


<a name="ablrb"></a><h4>Generating a Certificate Using the <tt>keytool</tt> Utility</h4>
<p>Use <tt>keytool</tt> to generate, import, and export certificates. By default, <tt>keytool</tt> creates a
keystore file in the directory where it is run.</p>
<ol><li><p>Change to the directory where the certificate is to be run.</p><p>Always generate the certificate in the directory containing the keystore and truststore files, by default <i>domain-dir</i><tt>/config</tt>. For information on changing the location of these files, see <a href="#gdhwg">Changing the Location of Certificate Files</a>.</p></li>
<li><p>Enter the following <tt>keytool</tt> command to generate the certificate in the keystore file, <tt>keystore.jks</tt>:</p><pre>keytool -genkey -alias <i>keyAlias</i>-keyalg RSA
 -keypass changeit
 -storepass changeit
-keystore keystore.jks</pre><p>Use any unique name as your <i>keyAlias</i>. If you have changed the keystore or private key password from their default, then substitute the new password for <tt>changeit</tt> in the above command. The default key password alias is &#8220;s1as.&#8221;</p><p>A prompt appears that asks for your name, organization, and other information that <tt>keytool</tt> uses to generate the certificate.</p></li>
<li><p>Enter the following <tt>keytool</tt> command to export the generated certificate to the file <tt>server.cer</tt> (or <tt>client.cer</tt> if you prefer):</p><pre>keytool -export -alias <i>keyAlias</i>-storepass changeit
 -file server.cer
 -keystore keystore.jks</pre></li>
<li><p>If a certificate signed by a certificate authority is required, see <a href="#ablrc">Signing a Digital Certificate Using the <tt>keytool</tt> Utility</a>.</p></li>
<li><p>To create the truststore file <tt>cacerts.jks</tt> and add the certificate to the truststore, enter the following <tt>keytool</tt> command:</p><pre>keytool -import -v -trustcacerts
-alias <i>keyAlias</i>
 -file server.cer
-keystore cacerts.jks
 -keypass changeit</pre></li>
<li><p>If you have changed the keystore or private key password from their default, then substitute the new password for <tt>changeit</tt> in the above command.</p><p>The tool displays information about the certificate and prompts whether you want to trust the certificate.</p></li>
<li><p>Type <tt>yes</tt>, then press Enter.</p><p>Then <tt>keytool</tt> displays something like this:</p><pre>Certificate was added to keystore
[Saving cacerts.jks]</pre></li>
<li><p>Restart the Enterprise Server.</p></li></ol>


<a name="ablrc"></a><h4>Signing a Digital Certificate Using the <tt>keytool</tt> Utility</h4>
<p>After creating a digital certificate, the owner must sign it to prevent forgery.
E-commerce sites, or those for which authentication of identity is important can purchase
a certificate from a well-known Certificate Authority (CA). If authentication is not a
concern, for example if private secure communications is all that is required, save
the time and expense involved in obtaining a CA certificate and use a
self-signed certificate.</p>
<ol><li><p>Follow the instructions on the CA's Web site for generating certificate key pairs.</p></li>
<li><p>Download the generated certificate key pair.</p><p>Save the certificate in the directory containing the keystore and truststore files, by default <i>domain-dir</i><tt>/config</tt> directory. See <a href="#gdhwg">Changing the Location of Certificate Files</a>.</p></li>
<li><p>In your shell, change to the directory containing the certificate.</p></li>
<li><p>Use <tt>keytool</tt> to import the certificate into the local keystore and, if necessary, the local truststore.</p><pre>keytool -import -v -trustcacerts
-alias <i>keyAlias</i>
 -file server.cer
-keystore cacerts.jks
 -keypass changeit
-storepass changeit</pre><p>If the keystore or private key password is not the default password, then substitute the new password for <tt>changeit</tt> in the above command.</p></li>
<li><p>Restart the Enterprise Server.</p></li></ol>


<a name="ablre"></a><h4>Deleting a Certificate Using the <tt>keytool</tt> Utility</h4>
<p>To delete an existing certificate, use the <tt>keytool -delete</tt> command, for example:</p><pre>keytool -delete
 -alias <i>keyAlias</i>
 -keystore <i>keystore-name</i>
 -storepass <i>password</i></pre>

<a name="ablrf"></a><h3>Using Network Security Services (NSS) Tools</h3>
<p>In the Clusters and Enterprise Profile, use Network Security Services (NSS) digital certificates
on the server-side to manage the database that stores private keys and certificates.
For the client side (appclient or stand-alone), use the JSSE format as discussed
in <a href="#ablqz">Using Java Secure Socket Extension (JSSE) Tools</a>.</p><p>The tools for managing security with Network Security Services (NSS) include the following:</p>
<ul><li><p><tt>certutil</tt>, a command-line utility for managing certificates and key databases. Some examples using the <tt>certutil</tt> utility are shown in <a href="#ablrg">Using the <tt>certutil</tt> Utility</a>.</p></li>
<li><p><tt>pk12util</tt>, a command-line utility used to import and export keys and certificates between the certificate/key databases and files in PKCS12 format. Some examples using the <tt>pk12util</tt> utility are shown in <a href="#ablrh">Importing and Exporting Certificates Using the <tt>pk12util</tt> Utility</a>.</p></li>
<li><p><tt>modutil</tt>, a command-line utility for managing PKCS #11 module information within <tt>secmod.db</tt> files or within hardware tokens. Some examples using the <tt>modutil</tt> utility are shown in <a href="#ablri">Adding and Deleting PKCS11 Modules using <tt>modutil</tt></a>.</p></li></ul>
<p>The tools are located in the <i>as-install</i><tt>/lib/</tt> directory. The following environment variables are
used to point to the location of the NSS security tools:</p>
<ul><li><p><tt>LD_LIBRARY_PATH =${</tt><i>as-install</i><tt>}/lib</tt></p></li>
<li><p><tt>${</tt><i>os.nss.path</i><tt>}</tt></p></li></ul>
<p>In the examples, the certificate common name (CN) is the name of
the client or server. The CN is also used during SSL handshake for
comparing the certificate name and the host name from which it originates. If
the certificate name and the host name do not match, warnings or exceptions
are generated during SSL handshake. In some examples, the certificate common name <tt>CN=localhost</tt>
is used for convenience so that all users can use that certificate instead
of creating a new one with their real host name.</p><p>The examples in the following sections demonstrate usage related to certificate handling using
NSS tools:</p>
<ul><li><p><a href="#ablrg">Using the <tt>certutil</tt> Utility</a></p></li>
<li><p><a href="#ablrh">Importing and Exporting Certificates Using the <tt>pk12util</tt> Utility</a></p></li>
<li><p><a href="#ablri">Adding and Deleting PKCS11 Modules using <tt>modutil</tt></a></p></li></ul>


<a name="ablrg"></a><h4>Using the <tt>certutil</tt> Utility</h4>
<p>Before running <tt>certutil</tt>, make sure that <tt>LD_LIBRARY_PATH</tt> points to the location of
the libraries required for this utility to run. This location can be identified
from the value of <tt>AS_NSS_LIB</tt> in <tt>asenv.conf</tt> (product wide configuration file).</p><p>The certificate database tool, <tt>certutil</tt>, is an NSS command-line utility that can create
and modify the Netscape Communicator <tt>cert8.db</tt> and <tt>key3.db</tt> database files. It can
also list, generate, modify, or delete certificates within the <tt>cert8.db</tt> file and create or
change the password, generate new public and private key pairs, display the contents
of the key database, or delete key pairs within the <tt>key3.db</tt> file.</p><p>The key and certificate management process generally begins with creating keys in the
key database, then generating and managing certificates in the certificate database. The following
document discusses certificate and key database management with NSS, including the syntax for
the <tt>certutil</tt> utility: <a href="http://www.mozilla.org/projects/security/pki/nss/tools/certutil.html">http://www.mozilla.org/projects/security/pki/nss/tools/certutil.html</a>.</p><p>Each of the items in the list below gives an example using
NSS and JSSE security tools to create and/or manage certificates.</p>
<ul><li><p>Generate a self-signed server and client certificate. In this example, the CN must be of the form <tt>hostname.domain.[com|org|net|...]</tt>.</p><p>In this example, <i>domain-dir</i><tt>/config</tt>. The <tt>serverseed.txt</tt> <tt>and clientseed.txt</tt> files can contain any random text. This random text will be used for generating the key pair.</p><pre>certutil -S -n $SERVER_CERT_NAME -x -t "u,u,u"
 -s "CN=$HOSTNAME.$HOSTDOMAIN, OU=Java Software, O=Sun Microsystems Inc., 
    L=Santa Clara, ST=CA, C=US"
 -m 25001 -o  $CERT_DB_DIR/Server.crt
 -d $CERT_DB_DIR -f passfile &#38;lt;$CERT_UTIL_DIR/serverseed.txt</pre><p>Generate the client certificate. This certificate is also a self-signed certificate.</p><pre>certutil -S -n $CLIENT_CERT_NAME  -x -t "u,u,u"
 -s "CN=MyClient, OU=Java Software, O=Sun Microsystems Inc., 
    L=Santa Clara, ST=CA, C=US"
 -m 25002 -o  $CERT_DB_DIR/Client.crt
 -d $CERT_DB_DIR -f passfile &#38;lt;$CERT_UTIL_DIR/clientseed.txt</pre></li>
<li><p>Verify the certificates generated in the previous bullet.</p><pre>certutil -V -u V -n $SERVER_CERT_NAME -d  $CERT_DB_DIR
certutil -V -u C -n $CLIENT_CERT_NAME -d  $CERT_DB_DIR</pre></li>
<li><p>Display available certificates.</p><pre>certutil -L -d  $CERT_DB_DIR</pre></li>
<li><p>Import an RFC text-formatted certificate into an NSS certificate database.</p><pre>certutil -A -a -n ${cert.nickname} -t ${cert.trust.options} 
-f ${pass.file} -i ${cert.rfc.file} 
-d ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Export a certificate from an NSS certificate database in RFC format.</p><pre>certutil -L -a -n ${cert.nickname} -f ${pass.file} 
-d ${admin.domain.dir}/${admin.domain}/config > cert.rfc</pre></li>
<li><p>Delete a certificate from an NSS certificate database.</p><pre>certutil -D -n ${cert.nickname} -f ${pass.file} 
-d ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Move a certificate from an NSS database to JKS format</p><pre>certutil -L -a -n ${cert.nickname} 
-d ${admin.domain.dir}/${admin.domain}/config > cert.rfc
keytool  -import -noprompt -trustcacerts -keystore ${keystore.file} 
-storepass ${keystore.pass} -alias ${cert.alias} -file cert.rfc</pre></li></ul>


<a name="ablrh"></a><h4>Importing and Exporting Certificates Using the <tt>pk12util</tt> Utility</h4>
<p>The command-line utility used to import and export keys and certificates between the
certificate/key databases and files in PKCS12 format is <tt>pk12util</tt>. PKCS12 is Public-Key
Cryptography Standards (PKCS) #12, Personal Information Exchange Syntax Standard. More description of the
<tt>pk12util</tt> utility can be read at <a href="http://www.mozilla.org/projects/security/pki/nss/tools/pk12util.html">http://www.mozilla.org/projects/security/pki/nss/tools/pk12util.html</a>.</p>
<ul><li><p>Import a PKCS12-formatted certificate into an NSS certificate database.</p><pre>pk12util -i ${cert.pkcs12.file} -k ${certdb.pass.file} 
-w ${cert.pass.file} -d ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Import a PKCS12-formatted certificate into an NSS certificate database token module.</p><pre>pk12util -i ${cert.pkcs12.file} -h ${token.name} -k ${certdb.pass.file} 
-w ${cert.pass.file} -d ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Export a certificate from an NSS certificate database in PKCS12 format.</p><pre>pk12util -o -n ${cert.nickname} -k ${pass.file} -w${cert.pass.file} 
-d ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Export a certificate from an NSS certificate database token module in PKCS12 format (useful for hardware accelerator configuration).</p><pre>pk12util -o -n ${cert.nickname} -h ${token.name} -k ${pass.file} 
-w ${cert.pass.file} -d ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Convert a PKCS12 certificate into JKS format (requires a Java source):</p><pre>&#38;lt;target name="convert-pkcs12-to-jks" depends="init-common">
   &#38;lt;delete file="${jks.file}" failonerror="false"/>
   &#38;lt;java classname="com.sun.enterprise.security.KeyTool">
      &#38;lt;arg line="-pkcs12"/>
      &#38;lt;arg line="-pkcsFile ${pkcs12.file}"/>
      &#38;lt;arg line="-pkcsKeyStorePass ${pkcs12.pass}"/>
      &#38;lt;arg line="-pkcsKeyPass ${pkcs12.pass}"/>
      &#38;lt;arg line="-jksFile ${jks.file}"/>
      &#38;lt;arg line="-jksKeyStorePass ${jks.pass}"/>
      &#38;lt;classpath>
         &#38;lt;pathelement path="${s1as.classpath}"/>
         &#38;lt;pathelement path="${env.JAVA_HOME}/jre/lib/jsse.jar"/>
      &#38;lt;/classpath>
   &#38;lt;/java>
&#38;lt;/target></pre></li></ul>


<a name="ablri"></a><h4>Adding and Deleting PKCS11 Modules using <tt>modutil</tt></h4>
<p>The <b>Security Module Database Tool</b>, <tt>modutil</tt>, is a command-line utility for managing PKCS #11 (Cryptographic Token
Interface Standard) module information within <tt>secmod.db</tt> files or within hardware tokens. You can use
the tool to add and delete PKCS #11 modules, change passwords, set defaults,
list module contents, enable or disable slots, enable or disable FIPS-140-1 compliance, and
assign default providers for cryptographic operations. This tool can also create <tt>key3.db</tt>, <tt>cert7.db</tt>,
and <tt>secmod.db</tt> security database files. For more information on this tool, see <a href="http://www.mozilla.org/projects/security/pki/nss/tools/modutil.html">http://www.mozilla.org/projects/security/pki/nss/tools/modutil.html</a>.</p>
<ul><li><p>Add a new PKCS11 module or token.</p><pre>modutil -add ${token.module.name} -nocertdb -force -mechanisms RSA:DSA:RC4:DES 
-libfile ${SCA.lib.path} -dbdir ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>Delete a PKCS11 module from an NSS store.</p><pre>modutil -delete ${token.module.name} -nocertdb -force -mechanisms RSA:DSA:RC4:DES 
-libfile ${SCA.lib.path} -dbdir ${admin.domain.dir}/${admin.domain}/config</pre></li>
<li><p>List available token modules in an NSS store.</p><pre>modutil -list  -dbdir ${admin.domain.dir}/${admin.domain}/config</pre></li></ul>


<a name="gcsno"></a><h3>Using Hardware Crypto Accelerator With Enterprise Server</h3>
<p>You can use hardware accelerator tokens to improve the cryptographic performance and to
furnish a secure key storage facility. Additionally, you can provide end users with
mobile secure key storage through smart cards. </p><p>Sun Java System Application Server supports the use of PKCS#11 tokens for SSL
or TLS communications and Network Security Services (NSS) tools for managing keys and
PKCS#11 tokens. This section describes how Enterprise Server provides that support and walks
you through the procedures for the related configurations.</p><p>J2SE 5.0 PKCS#11 providers can be easily integrated with the Enterprise Server
runtime. Through these providers, you can use hardware accelerators and other PKCS#11 tokens in
Enterprise Server to achieve fast performance and to protect the private key inherent
in SSL or TLS communications.</p><p>This section contains the following topics:</p>
<ul><li><p><a href="#gcsny">About Configuring Hardware Crypto Accelerators</a></p></li>
<li><p><a href="#gcsos">Configuring PKCS#11 Tokens</a></p></li>
<li><p><a href="#gcsnb">Managing Keys And Certificates</a></p></li>
<li><p><a href="#gcsoc">Configuring J2SE 5.0 PKCS#11 Providers</a></p></li></ul>


<a name="gcsny"></a><h4>About Configuring Hardware Crypto Accelerators</h4>
<p>Sun GlassFish Enterprise Server has been tested with Sun Crypto Accelerator 1000 (SCA-1000)
and SCA-4000.</p><p>Enterprise Server can communicate with PKCS#11 tokens. Packaged with Enterprise Server are an
NSS PKCS#11 token library (for the NSS Internal PKCS#11 Module, commonly known as
the NSS soft token) and NSS command-line management tools. For more details, see
<a href="#ablrf">Using Network Security Services (NSS) Tools</a>.</p><p>Use the NSS tools to create keys and certificates on PKCS#11 tokens and
J2SE PKCS#11 providers to access token keys and certificates at runtime. A PKCS#11
provider is a cryptographic service provider that acts as a wrapper around a
native PKCS#11 library. A PKCS#11 token generally refers to all the hardware and
software tokens with a native PKCS#11 interface. A hardware token is a PKCS#11
token implemented in physical devices, such as hardware accelerators and smart cards. A
software token is a PKCS#11 token implemented entirely in software.</p>
<hr><p><b>Note - </b>If you run Enterprise Server on the J2SE 1.4.x platform, only one PKCS#11
token, the NSS soft token, is supported.</p>
<hr>
<p>For the Microsoft Windows environment, add the location of NSS libraries <i>AS_NSS</i>
and the NSS tools directory, <i>AS_NSS_BIN</i> to the PATH environment variable. For simplicity,
the procedures described in this section use UNIX commands only. You should replace
the UNIX variables with the Windows variables, where appropriate.</p><p>Configuring the hardware crypto accelerators is divided into two main procedures: </p>
<ul><li><p><a href="#gcsos">Configuring PKCS#11 Tokens</a></p></li>
<li><p><a href="#gcsoc">Configuring J2SE 5.0 PKCS#11 Providers</a></p></li></ul>


<a name="gcsos"></a><h4>Configuring PKCS#11 Tokens</h4>
<p>This section describes how to configure PKCS#11 tokens with the NSS security tool
<tt>modutil</tt>. Use the following procedure to configure a PKCS#11 token.</p><p>Enter the following command (all on one line):</p><pre>modutil -dbdir <i>AS_NSS_DB</i> -nocertdb -force -add <i>moduleName</i> -libfile
 <i>absolute_path_of_pkcs11_library</i> -mechanisms <i>list_of_security_mechanisms</i></pre><p>where, <i>AS_NSS_DB</i> is the NSS database directory (same as <tt>AS_DOMAIN_CONFIG</tt> when you use
the Domain Administration Server (DAS))</p><p>For example, to configure a hardware accelerator token, enter the following (all on
one line):</p><pre>modutil -dbdir <i>AS_NSS_DB</i> -nocertdb -force -add "Sun Crypto Accelerator" -libfile
 /opt/SUNWconn/crypto/lib/libpkcs11.so -mechanisms RSA:DSA:RC4:DES</pre><p>The hardware accelerator in this example is a SCA&#8211;1000 cryptographic accelerator. The corresponding
PKCS#11 library, by default, is located in <tt>/opt/SUNWconn/crypto/lib/libpkcs11.so</tt>.</p><p>The <tt>mechanisms</tt> must be a complete list of the cryptographic mechanisms that are
available in the token. To use just a few of the available cryptographic
mechanisms, see <a href="#gcsoc">Configuring J2SE 5.0 PKCS#11 Providers</a>. For a list of all supported mechanisms, see the
<tt>modutil</tt> documentation on the NSS Security Tools site at <a href="http://www.mozilla.org/projects/security/pki/nss/tools">http://www.mozilla.org/projects/security/pki/nss/tools</a>.</p><p>The examples that follow assume that the token name specified at token installation
time is <tt>mytoken</tt>.</p><p>To verify that the hardware accelerator is configured properly, enter the following command:
</p><pre>modutil -list -dbdir <i>AS_NSS_DB</i></pre><p>The standard output will look similar to the following:</p><pre>Using database directory /var/opt/SUNWappserver/domains/domain1/config ...

Listing of PKCS#11 Modules
-----------------------------------------------------------
  1. NSS Internal PKCS#11 Module
         slots: 2 slots attached
        status: loaded

         slot: NSS Internal Cryptographic Services                            
        token: NSS Generic Crypto Services

         slot: NSS User Private Key and Certificate Services                  
        token: NSS Certificate DB

  2. Sun Crypto Accelerator
        library name: /opt/SUNWconn/crypto/lib/libpkcs11.so
         slots: 1 slot attached
        status: loaded

         slot: Sun Crypto Accelerator:mytoken
        token: mytoken
-----------------------------------------------------------

 </pre>

<a name="gcsnb"></a><h4>Managing Keys And Certificates</h4>
<p>This section describes a few common procedures for creating and managing keys and
certificates using <tt>certutil</tt> and <tt>pk12util</tt>. For details on <tt>certutil</tt> and <tt>pk12util</tt>, see <a href="#ablrf">Using Network Security Services (NSS) Tools</a> and documentation
on the NSS Security Tools site at <a href="http://www.mozilla.org/projects/security/pki/nss/tools">http://www.mozilla.org/projects/security/pki/nss/tools</a>.</p>
<hr><p><b>Note - </b>By configuring a PKCS#11 provider in the <tt>java.security</tt> properties file (located in the
<i>JAVA_HOME</i><tt>/jre/lib/security</tt> directory of the Java runtime), you can also use the J2SE
<tt>keytool</tt> utility to manage keys and certificates. For details on using <tt>keytool</tt>,
and Java PKCS#11 Reference Guide at <a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/p11guide.html">http://java.sun.com/j2se/1.5.0/docs/guide/security/p11guide.html</a>. </p>
<hr>
<p>This section describes the following topics:</p>
<ul><li><p><a href="#gcsov">Listing Keys and Certificates </a></p></li>
<li><p><a href="#gcsog">Working With Private Keys and Certificates</a></p></li></ul>


<a name="gcsov"></a><h5>Listing Keys and Certificates </h5>

<ul><li><p>To list the keys and certificates in the configured PKCS#11 tokens, run the following command:</p><pre>certutil -L -d <i>AS_NSS_DB</i> [-h <i>tokenname</i>]</pre><p>For example, to list the contents of the default NSS soft token, type:</p><pre>certutil -L -d <i>AS_NSS_DB</i></pre><p> The standard output will be similar to the following:</p><pre>verisignc1g1                  T,c,c
verisignc1g2                  T,c,c
verisignc1g3                  T,c,c
verisignc2g3                  T,c,c
verisignsecureserver          T,c,c
verisignc2g1                  T,c,c
verisignc2g2                  T,c,c
verisignc3g1                  T,c,c
verisignc3g2                  T,c,c
verisignc3g3                  T,c,c
s1as                          u,u,u</pre><p>The output displays the name of the token in the left column and a set of three trust attributes in the right column. For Enterprise Server certificates, it is usually <tt>T,c,c</tt>. Unlike the J2SE <tt>java.security.KeyStore</tt> API, which contains only one level of trust, the NSS technology contains several levels of trust. Enterprise Server is primarily interested in the first trust attribute, which describes how this token uses SSL. For this attribute:</p><table><tr><td align="left" valign="top" scope="row"><p><tt>T</tt> indicates that the Certificate Authority (CA) is trusted for issuing client certificates.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>u</tt> indicates that you can use the certificates (and keys) for authentication or signing. </p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>The attribute combination of <tt>u,u,u</tt> indicates that a private key exists in the database.</p></td>
</tr>
</table></li>
<li><p>To list the contents of the hardware token, <tt>mytoken</tt>, run the following command:</p><pre>certutil -L -d <i>AS_NSS_DB</i> -h mytoken</pre><p>You will be prompted for the password for the hardware token. The standard output is similar to the following:</p><pre>Enter Password or Pin for "mytoken":
mytoken:Server-Cert                                       &#38;#9;u,u,u</pre></li></ul>


<a name="gcsog"></a><h5>Working With Private Keys and Certificates</h5>
<p>Use <tt>certutil</tt> to create self-signed certificates and to import or export certificates. To
import or export private keys, use the <tt>pk12util</tt> utility. For more details,
see <a href="#ablrf">Using Network Security Services (NSS) Tools</a></p>
<hr><p><b>Caution - </b> In Enterprise Server, do not modify the NSS password directly with the
NSS tools <tt>certutil</tt> and <tt>modutil</tt>. If you do so, security data in Enterprise
Server might be corrupted.</p>
<hr>


<a name="gcsoc"></a><h4>Configuring J2SE 5.0 PKCS#11 Providers</h4>
<p>Enterprise Server relies on J2SE PKCS#11 providers to access keys and certificates that
are located in PKCS#11 tokens at runtime. By default, Enterprise Server configures a
J2SE PKCS#11 provider for the NSS soft token. This section describes how to
override the default configuration for the J2SE PKCS#11 provider.</p><p>In Enterprise Server, the following default PKCS#11 configuration parameters are generated for each
PKCS#11 token.</p>
<ul><li><p>Configuration for the default NSS soft token:</p><pre>name=internal
library=${com.sun.enterprise.nss.softokenLib}
nssArgs="configdir='${com.sun.appserv.nss.db}'
 certPrefix='' keyPrefix='' secmod='secmod.db'"
slot=2
omitInitialize = true</pre></li>
<li><p>Configuration for the SCA 1000 hardware accelerator:</p><pre>name=HW1000
library=/opt/SUNWconn/crypto/lib/libpkcs11.so
slotListIndex=0
omitInitialize=true</pre></li></ul>
<p>These configurations conform to the syntax described in the Java PKCS#11 Reference Guide.
</p>
<hr><p><b>Note - </b>The name parameter has no requirements other than that it must be unique.
Certain older versions of J2SE 5.0 support alphanumeric characters only. </p>
<hr>
<p>You can override the default configuration parameters by creating a custom configuration file.
For example, you can explicitly disable the RSA Cipher and RSA Key Pair
Generator in SCA&#8211;1000. For details on disabling the RSA Cipher and RSA Key
Pair Generator, see <a href="http://www.mozilla.org/projects/security/pki/nss/tools">http://www.mozilla.org/projects/security/pki/nss/tools</a>. </p><p>To create a custom configuration file:</p>
<ol><li><p>Create a configuration file called <i>as-install</i><tt>/mypkcs11.cfg</tt> with the following code and save the file.</p><pre>name=HW1000
library=/opt/SUNWconn/crypto/lib/libpkcs11.so
slotListIndex=0
disabledMechanisms = {
&#38;#9;CKM_RSA_PKCS
&#38;#9;CKM_RSA_PKCS_KEY_PAIR_GEN
}
omitInitialize=true</pre></li>
<li><p>Update the NSS database, if necessary. In this case, update the NSS database so that it will disable RSA. </p><p>Run the following command :</p><pre>modutil -undefault "Sun Crypto Accelerator" -dbdir <i>AS_NSS_DB</i> -mechanisms RSA</pre><p>The name of the algorithm on the <tt>mechanisms</tt> list differs from the one in the default configuration. For a list of valid <tt>mechanisms</tt> in NSS, see the <tt>modutil</tt> documentation on the NSS Security Tools site at <a href="http://www.mozilla.org/projects/security/pki/nss/tools">http://www.mozilla.org/projects/security/pki/nss/tools</a>.</p></li>
<li><p>Update the server with this change by adding a property in the appropriate location, as follows:</p><pre>&#38;lt;property name="mytoken" value="&#38;InstallDir;/mypkcs11.cfg"/></pre><p>The location for the property could be one of the following:</p>
<ul><li><p>If the provider is for a DAS or server instance, add the property under the associated <tt>&#38;lt;security-service></tt>.</p></li>
<li><p>If the provider is for a node agent, add the property under the associated <tt>&#38;lt;node-agent></tt> element in the <tt>domain.xml</tt> file.</p></li></ul>
</li>
<li><p>Restart the Enterprise Server.</p><p>The customized configurations will be in effect after the restart.</p></li></ol>



<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p11.html">Previous</a></td>
<td></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p13.html">Next</a></td>
</tr>
</table>



</body>
</html>

