<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8">
<title>Securing Applications - Sun GlassFish Enterprise Server v3 Prelude Developer's Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-10-01">
</head>

<body>


<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&#160;</td>
<td><a href="p8.html">Previous</a></td>
<td></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p10.html">Next</a></td>
</tr>
</table>


<a name="beabg"></a>Chapter&#160;4<h3>Securing Applications</h3><a name="indexterm-67"></a><p>This chapter describes how to write secure Java EE applications, which contain components
that perform user authentication and access authorization for the business logic of Java
EE components. </p><p>For information about administrative security for the Enterprise Server, see <a href="http://docs.sun.com/doc/820-4495/ablnk?a=view">Chapter 6, Administering System Security, in <i>Sun GlassFish Enterprise Server v3 Prelude Administration Guide</i></a>.</p><p>For general information about Java EE security, see &#8220;Chapter 29: Introduction to Security
in Java EE&#8221; in the <a href="http://java.sun.com/javaee/5/docs/tutorial/doc/index.html">Java EE 5 Tutorial</a>.</p><p>This chapter contains the following sections:</p>
<ul><li><p><a href="#beabh">Security Goals</a></p></li>
<li><p><a href="#beabi">Enterprise Server Specific Security Features</a></p></li>
<li><p><a href="#beabj">Container Security</a></p></li>
<li><p><a href="#beacr">Roles, Principals, and Principal to Role Mapping</a></p></li>
<li><p><a href="#beabo">Realm Configuration</a></p></li>
<li><p><a href="#beabt">JACC Support</a></p></li>
<li><p><a href="#beabu">Pluggable Audit Module Support</a></p></li>
<li><p><a href="#beabx">The <tt>server.policy</tt> File</a></p></li>
<li><p><a href="#beacm">Programmatic Login</a></p></li>
<li><p><a href="#beacq">User Authentication for Single Sign-on</a></p></li></ul>

<hr><p><b>Note - </b>For GlassFish v3 Prelude, EJB modules are not supported unless the optional EJB
container add-on component is downloaded from the Update Tool. Web services are not supported
unless the optional Metro (JSR 109) add-on component is downloaded from the Update
Tool. For information about the Update Tool, see the <a href="http://docs.sun.com/doc/820-5968"><i>Sun GlassFish Enterprise Server v3 Prelude Installation Guide</i></a>.</p>
<hr>


<a name="beabh"></a><h3>Security Goals</h3>
<a name="indexterm-68"></a><p>In an enterprise computing environment, there are many security risks. The goal of
the Sun GlassFish Enterprise Server is to provide highly secure, interoperable, and distributed
component computing based on the Java EE security model. Security goals include:</p>
<ul><li><p>Full compliance with the Java EE security model. This includes EJB and servlet role-based authorization.</p></li>
<li><p>Support for single sign-on across all Enterprise Server applications within a single security domain.</p></li>
<li><p>Support for several underlying authentication realms.</p></li>
<li><p>Support for declarative security through Enterprise Server specific XML-based role mapping.</p></li>
<li><p><a name="indexterm-69"></a>Support for Java Authorization Contract for Containers (JACC) pluggable authorization as included in the Java EE specification and defined by <a href="http://www.jcp.org/en/jsr/detail?id=115">Java Specification Request (JSR) 115</a>.</p></li>
<li><p><a name="indexterm-70"></a>Support for Java<sup>TM</sup> Authentication Service Provider Interface for Containers as included in the Java EE specification and defined by <a href="http://www.jcp.org/en/jsr/detail?id=196">JSR 196</a>.</p></li>
<li><p><a name="indexterm-71"></a>Support for Web Services Interoperability Technologies (WSIT) as described in <a href="https://wsit-docs.dev.java.net/releases/m5/">The WSIT Tutorial</a>.</p></li></ul>


<a name="beabi"></a><h3>Enterprise Server Specific Security Features</h3>
<a name="indexterm-72"></a><a name="indexterm-73"></a><a name="indexterm-74"></a><p>The Enterprise Server supports the Java EE security model, as well as the
following features which are specific to the Enterprise Server:</p>
<ul><li><p>Single sign-on across all Enterprise Server applications within a single security domain; see <a href="#beacq">User Authentication for Single Sign-on</a></p></li>
<li><p>Programmatic login; see <a href="#beacm">Programmatic Login</a></p></li></ul>


<a name="beabj"></a><h3>Container Security</h3>
<a name="indexterm-75"></a><p>The component containers are responsible for providing Java EE application security. The container
provides two security forms:</p>
<ul><li><p><a href="#beabl">Declarative Security</a></p></li>
<li><p><a href="#beabk">Programmatic Security</a></p></li></ul>
<p><a name="indexterm-76"></a><a name="indexterm-77"></a><b>Annotations</b> (also called metadata) enable a declarative style of programming, and so encompass
both the declarative and programmatic security concepts. Users can specify information about security within
a class file using annotations. When the application is deployed, this information can
either be used by or overridden by the application or module deployment descriptor.</p>

<a name="beabl"></a><h4>Declarative Security</h4>
<p><a name="indexterm-78"></a><b>Declarative security</b> means that the security mechanism for an application is declared and handled
externally to the application. Deployment descriptors describe the Java EE application&#8217;s security structure, including
security roles, access control, and authentication requirements.</p><p>The Enterprise Server supports the deployment descriptors specified by Java EE and has
additional security elements included in its own deployment descriptors. Declarative security is the
application deployer&#8217;s responsibility. For more information about Sun-specific deployment descriptors, see the <a href="http://docs.sun.com/doc/820-4502"><i>Sun GlassFish Enterprise Server v3 Prelude Application Deployment Guide</i></a>.</p><p>There are two levels of declarative security, as follows:</p>
<ul><li><p><a href="#beabm">Application Level Security</a></p></li>
<li><p><a href="#beabn">Component Level Security</a></p></li></ul>


<a name="beabm"></a><h5>Application Level Security</h5>
<a name="indexterm-79"></a><p>For an individually deployed web or EJB module, you define roles using <tt>@DeclareRoles</tt>
annotations or <tt>role-name</tt> elements in the Java EE deployment descriptor files <tt>web.xml</tt> or
<tt>ejb-jar.xml</tt>.</p><p>To map roles to principals and groups, define matching <tt>security-role-mapping</tt> elements in
the <tt>sun-ejb-jar.xml</tt> or <tt>sun-web.xml</tt> file for each <tt>role-name</tt> used by the application. For more
information, see <a href="#beacr">Roles, Principals, and Principal to Role Mapping</a>.</p>

<a name="beabn"></a><h5>Component Level Security</h5>
<a name="indexterm-80"></a><a name="indexterm-81"></a><p>Component level security encompasses web components and EJB components.</p><p>A secure web container authenticates users and authorizes access to a servlet or
JSP by using the security policy laid out in the servlet XML deployment
descriptors (<tt>web.xml</tt> and <tt>sun-web.xml</tt> files).</p><p><a name="indexterm-82"></a><a name="indexterm-83"></a>The EJB container is responsible for authorizing access to a bean method by
using the security policy laid out in the EJB XML deployment descriptors (<tt>ejb-jar.xml</tt>
and <tt>sun-ejb-jar.xml</tt> files).</p>

<a name="beabk"></a><h4>Programmatic Security</h4>
<p><a name="indexterm-84"></a><b>Programmatic security</b> involves an EJB component or servlet using method calls to the security
API, as specified by the Java EE security model, to make business logic
decisions based on the caller or remote user&#8217;s security role. Programmatic security should only
be used when declarative security alone is insufficient to meet the application&#8217;s security
model.</p><p><a name="indexterm-85"></a>The Java EE specification defines programmatic security as consisting of two methods of
the EJB <tt>EJBContext</tt> interface and two methods of the servlet <tt>HttpServletRequest</tt> interface.
The Enterprise Server supports these interfaces as specified in the specification.</p><p>For more information on programmatic security, see the following:</p>
<ul><li><p>The Java EE Specification</p></li>
<li><p><a href="#beacm">Programmatic Login</a></p></li></ul>


<a name="beacr"></a><h3>Roles, Principals, and Principal to Role Mapping</h3>
<a name="indexterm-86"></a><a name="indexterm-87"></a><a name="indexterm-88"></a><a name="indexterm-89"></a><p>For applications, you define roles in <tt>@DeclareRoles</tt> annotations or the Java EE deployment
descriptor file <tt>application.xml</tt>. You define the corresponding role mappings in the Enterprise Server
deployment descriptor file <tt>sun-application.xml</tt>. For individually deployed web or EJB modules, you define roles
in <tt>@DeclareRoles</tt> annotations or the Java EE deployment descriptor files <tt>web.xml</tt> or <tt>ejb-jar.xml</tt>.
You define the corresponding role mappings in the Enterprise Server deployment descriptor files
<tt>sun-web.xml</tt> or <tt>sun-ejb-jar.xml</tt>.</p><p>For more information regarding Java EE deployment descriptors, see the Java EE Specification.
For more information regarding Enterprise Server deployment descriptors, see <a href="http://docs.sun.com/doc/820-4502/beaqi?a=view">Appendix A, <i>Deployment Descriptor Files,</i> in <i>Sun GlassFish Enterprise Server v3 Prelude Application Deployment Guide</i></a>.</p><p>Each <tt>security-role-mapping</tt> element in the <tt>sun-application.xml</tt>, <tt>sun-web.xml</tt>, or <tt>sun-ejb-jar.xml</tt> file maps a
role name permitted by the application or module to principals and groups. For
example, a <tt>sun-web.xml</tt> file for an individually deployed web module might contain the
following:</p><pre>&#60;sun-web-app>
    &#60;security-role-mapping>
        &#60;role-name>manager&#60;/role-name>
        &#60;principal-name>jgarcia&#60;/principal-name>
        &#60;principal-name>mwebster&#60;/principal-name>
        &#60;group-name>team-leads&#60;/group-name>
    &#60;/security-role-mapping>
    &#60;security-role-mapping>
        &#60;role-name>administrator&#60;/role-name>
        &#60;principal-name>dsmith&#60;/principal-name>
    &#60;/security-role-mapping>
&#60;/sun-web-app></pre><p>A role can be mapped to either specific principals or to groups (or
both). The principal or group names used must be valid principals or groups
in the realm for the application or module. Note that the <tt>role-name</tt>
in this example must match the <tt>@DeclareRoles</tt> annotations or the <tt>role-name</tt> in
the <tt>security-role</tt> element of the corresponding <tt>web.xml</tt> file.</p><p>You can also specify a custom principal implementation class. This provides more flexibility
in how principals can be assigned to roles. A user's JAAS login module
now can authenticate its custom principal, and the authenticated custom principal can further
participate in the Enterprise Server authorization process. For example:</p><pre>&#60;security-role-mapping>
    &#60;role-name>administrator&#60;/role-name>
    &#60;principal-name class-name="CustomPrincipalImplClass">
        dsmith
    &#60;/principal-name>
&#60;/security-role-mapping></pre><p>You can specify a default principal and a default principal to role mapping,
each of which applies to the entire Enterprise Server. The default principal to
role mapping maps group principals to the same named roles. Web modules that
omit the <tt>run-as</tt> element in <tt>web.xml</tt> use the default principal. Applications and
modules that omit the <tt>security-role-mapping</tt> element use the default principal to role mapping. These
defaults are part of the Security Service, which you can access in the
following ways:</p>
<ul><li><p><a name="indexterm-90"></a>In the Administration Console, select the Security component under the relevant configuration. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-91"></a><a name="indexterm-92"></a>Use the <tt>asadmin set</tt> command. For details, see the <a href="http://docs.sun.com/doc/820-4497"><i>Sun GlassFish Enterprise Server v3 Prelude Reference Manual</i></a>. For example, you can set the default principal as follows.</p><pre>asadmin set --user adminuser server-config.security-service.default-principal=dsmith
asadmin set --user adminuser server-config.security-service.default-principal-password=secret</pre><p>You can set the default principal to role mapping as follows.</p><pre>asadmin set --user adminuser server-config.security-service.activate-default-principal-to-role-mapping=true
asadmin set --user adminuser server-config.security-service.mapped-principal-class=CustomPrincipalImplClass</pre></li></ul>


<a name="beabo"></a><h3>Realm Configuration</h3>
<p>This section covers the following topics:</p>
<ul><li><p><a href="#beabp">Supported Realms</a></p></li>
<li><p><a href="#beabq">How to Configure a Realm</a></p></li>
<li><p><a href="#beabr">How to Set a Realm for a Web Application or EJB Module</a></p></li>
<li><p><a href="#beabs">Creating a Custom Realm</a></p></li></ul>


<a name="beabp"></a><h4>Supported Realms</h4>
<a name="indexterm-93"></a><a name="indexterm-94"></a><p>The following realms are supported in the current release of the Enterprise Server:</p>
<ul><li><p><a name="indexterm-95"></a><tt>file</tt> &#8211; Stores user information in a file. This is the default realm when you first install the Enterprise Server.</p></li>
<li><p><a name="indexterm-96"></a><tt>ldap</tt> &#8211; Stores user information in an LDAP directory.</p></li>
<li><p><a name="indexterm-97"></a><a name="indexterm-98"></a><tt>jdbc</tt> &#8211; Stores user information in a database.</p><p>In the JDBC realm, the server gets user credentials from a database. The Enterprise Server uses the database information and the enabled JDBC realm option in the configuration file. For digest authentication, a JDBC realm should be created with <tt>jdbcDigestRealm</tt> as the JAAS context.</p></li>
<li><p><a name="indexterm-99"></a><tt>certificate</tt> &#8211; Sets up the user identity in the Enterprise Server security context, and populates it with user data obtained from cryptographically verified client certificates.</p></li></ul>

<hr><p><b>Note - </b>The <tt>solaris</tt> realm is not supported in GlassFish v3 Prelude.</p>
<hr>
<p>For information about configuring realms, see <a href="#beabq">How to Configure a Realm</a>.</p>

<a name="beabq"></a><h4>How to Configure a Realm</h4>
<a name="indexterm-100"></a><p>You can configure a realm in one of these ways:</p>
<ul><li><p><a name="indexterm-101"></a>In the Administration Console, open the Security component under the relevant configuration and go to the Realms page. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-102"></a><a name="indexterm-103"></a>Use the <tt>asadmin create-auth-realm</tt> command to configure realms on local servers. For details, see the <a href="http://docs.sun.com/doc/820-4497"><i>Sun GlassFish Enterprise Server v3 Prelude Reference Manual</i></a>.</p></li></ul>


<a name="beabr"></a><h4>How to Set a Realm for a Web Application or EJB Module</h4>
<p><a name="indexterm-104"></a>The following deployment descriptor elements have optional <tt>realm</tt> or <tt>realm-name</tt> data subelements or attributes
that override the domain&#8217;s default realm:</p>
<ul><li><p><tt>web-app</tt> element in <tt>web.xml</tt></p></li>
<li><p><tt>as-context</tt> element in <tt>sun-ejb-jar.xml</tt></p></li></ul>
<p>For more information about the deployment descriptor files and elements, see <a href="http://docs.sun.com/doc/820-4502/beaqi?a=view">Appendix A, <i>Deployment Descriptor Files,</i> in <i>Sun GlassFish Enterprise Server v3 Prelude Application Deployment Guide</i></a>.</p>

<a name="beabs"></a><h4>Creating a Custom Realm</h4>
<a name="indexterm-105"></a><a name="indexterm-106"></a><a name="indexterm-107"></a><a name="indexterm-108"></a><p>You can create a custom realm by providing a custom Java Authentication and
Authorization Service (JAAS) login module class and a custom realm class. Note that
client-side JAAS login modules are not suitable for use with the Enterprise Server.
</p><p>To activate the custom login modules and realms, place the JAR files in
the <i>domain-dir</i><tt>/lib</tt> directory or the class files in the <i>domain-dir</i><tt>/lib/classes</tt> directory, then restart the
server. For more information about class loading in the Enterprise Server, see <a href="p6.html">Chapter&#160;2, Class Loaders</a>.</p><p><a name="indexterm-109"></a>JAAS is a set of APIs that enable services to authenticate and enforce
access controls upon users. JAAS provides a pluggable and extensible framework for programmatic
user authentication and authorization. JAAS is a core API and an underlying technology
for Java EE security mechanisms. For more information about JAAS, refer to the JAAS
specification for Java SDK, available at <a href="http://java.sun.com/products/jaas/">http://java.sun.com/products/jaas/</a>.</p><p>For general information about realms and login modules, see &#8220;Chapter 29: Introduction to
Security in Java EE&#8221; in the <a href="http://java.sun.com/javaee/5/docs/tutorial/doc/index.html">Java EE 5 Tutorial</a>.</p><p>For Javadoc tool pages relevant to custom realms, go to <a href="https://glassfish.dev.java.net/nonav/api/v3-prelude/index.html">https://glassfish.dev.java.net/nonav/api/v3-prelude/index.html</a> and click
on the <tt>com.sun.appserv.security</tt> package.</p><p><a name="indexterm-110"></a><a name="indexterm-111"></a>Custom login modules must extend the <tt>com.sun.appserv.security.AppservPasswordLoginModule</tt> class. This class implements <tt>javax.security.auth.spi.LoginModule</tt>. Custom
login modules must not implement <tt>LoginModule</tt> directly.</p><p>Custom login modules must provide an implementation for one abstract method defined in
<tt>AppservPasswordLoginModule</tt>:</p><pre>abstract protected void authenticateUser() throws LoginException</pre><p>This method performs the actual authentication. The custom login module must not implement
any of the other methods, such as <tt>login()</tt>, <tt>logout()</tt>, <tt>abort()</tt>, <tt>commit()</tt>, or
<tt>initialize()</tt>. Default implementations are provided in <tt>AppservPasswordLoginModule</tt> which hook into the Enterprise Server infrastructure.</p><p>The custom login module can access the following protected object fields, which it
inherits from <tt>AppservPasswordLoginModule</tt>. These contain the user name and password of the user
to be authenticated:</p><pre>protected String _username;
protected String _password;</pre><p>The <tt>authenticateUser()</tt> method must end with the following sequence:</p><pre>String[] grpList;
// populate grpList with the set of groups to which
// _username belongs in this realm, if any
commitUserAuthentication(_username, _password, 
  _currentRealm, grpList);</pre><p><a name="indexterm-112"></a>Custom realms must extend the <tt>com.sun.appserv.security.AppservRealm</tt> class and implement the following methods:</p><pre>public void init(Properties props) throws BadRealmException, 
    NoSuchRealmException</pre><p>This method is invoked during server startup when the realm is initially loaded.
The <tt>props</tt> argument contains the properties defined for this realm in <tt>domain.xml</tt>. The realm
can do any initialization it needs in this method. If the method returns
without throwing an exception, the Enterprise Server assumes that the realm is ready
to service authentication requests. If an exception is thrown, the realm is disabled.</p><pre>public String getAuthType()</pre><p>This method returns a descriptive string representing the type of authentication done by
this realm.</p><pre>public abstract Enumeration getGroupNames(String username) throws 
    InvalidOperationException, NoSuchUserException</pre><p>This method returns an <tt>Enumeration</tt> (of <tt>String</tt> objects) enumerating the groups (if
any) to which the given <tt>username</tt> belongs in this realm.</p>
<hr><p><b>Note - </b>The array passed to the <tt>commitUseAuthentication</tt> method should be newly created and otherwise
unreferenced. This is because the group name array elements are set to null
after authentication as part of cleanup. So the second time your custom realm
executes it returns an array with null elements.</p><p>Ideally, your custom realm should not return member variables from the <tt>authenticate</tt> method.
It should return local variables as the default <tt>JDBCRealm</tt> does. Your custom
realm can create a local <tt>String</tt> array in its <tt>authenticate</tt> method, copy the
values from the member variables, and return the <tt>String</tt> array. Or it can
use <tt>clone</tt> on the member variables.</p>
<hr>


<a name="beabt"></a><h3>JACC Support</h3>
<p><a name="indexterm-113"></a><a name="indexterm-114"></a><a name="indexterm-115"></a><a name="indexterm-116"></a><a name="indexterm-117"></a>JACC (Java Authorization Contract for Containers) is part of the Java EE specification and
defined by <a href="http://www.jcp.org/en/jsr/detail?id=115">JSR 115</a>. JACC defines an interface for pluggable authorization providers. Specifically, JACC
is used to plug in the Java policy provider used by the container
to perform Java EE caller access decisions. The Java policy provider performs Java
policy decisions during application execution. This provides third parties with a mechanism to
develop and plug in modules that are responsible for answering authorization decisions during Java
EE application execution. The interfaces and rules used for developing JACC providers are
defined in the JACC 1.0 specification.</p><p><a name="indexterm-118"></a>The Enterprise Server provides a simple file-based JACC-compliant authorization engine as a default
JACC provider, named <tt>default</tt>. An alternate provider named <tt>simple</tt> is also provided. To
configure an alternate provider using the Administration Console, open the Security component under
the relevant configuration, and select the JACC Providers component. For details, click the
Help button in the Administration Console.</p>

<a name="beabu"></a><h3>Pluggable Audit Module Support</h3>
<a name="indexterm-119"></a><a name="indexterm-120"></a><p>Audit modules collect and store information on incoming requests (servlets, EJB components) and
outgoing responses. You can create a custom audit module. This section covers the
following topics:</p>
<ul><li><p><a href="#beabv">Configuring an Audit Module</a></p></li>
<li><p><a href="#beabw">The <tt>AuditModule</tt> Class</a></p></li></ul>
<p>For additional information about audit modules, see <a href="http://developers.sun.com/prodtech/appserver/reference/techart/ws_mgmt3.html#8.2">Audit Callbacks</a>.</p>

<a name="beabv"></a><h4>Configuring an Audit Module</h4>
<p>To configure an audit module, you can perform one of the following tasks:</p>
<ul><li><p><a name="indexterm-121"></a>To specify an audit module using the Administration Console, open the Security component under the relevant configuration, and select the Audit Modules component. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-122"></a><a name="indexterm-123"></a>You can use the <tt></tt><tt>asadmin create-audit-module</tt> command to configure an audit module. For details, see the <a href="http://docs.sun.com/doc/820-4497"><i>Sun GlassFish Enterprise Server v3 Prelude Reference Manual</i></a>.</p></li></ul>


<a name="beabw"></a><h4>The <tt>AuditModule</tt> Class</h4>
<a name="indexterm-124"></a><p>You can create a custom audit module by implementing a class that extends
<tt>com.sun.appserv.security.audit.AuditModule</tt>. </p><p>For Javadoc tool pages relevant to audit modules, go to <a href="https://glassfish.dev.java.net/nonav/api/v3-prelude/index.html">https://glassfish.dev.java.net/nonav/api/v3-prelude/index.html</a> and click
on the <tt>com.sun.appserv.security.audit</tt> package.</p><p>The <tt>AuditModule</tt> class provides default &#8220;no-op&#8221; implementations for each of the following methods,
which your custom class can override.</p><pre>public void init(Properties props)</pre><p>The preceding method is invoked during server startup when the audit module is
initially loaded. The <tt>props</tt> argument contains the properties defined for this module in
<tt>domain.xml</tt>. The module can do any initialization it needs in this method. If
the method returns without throwing an exception, the Enterprise Server assumes the module realm
is ready to service audit requests. If an exception is thrown, the module
is disabled.</p><pre>public void authentication(String user, String realm, boolean success)</pre><p><a name="indexterm-125"></a><a name="indexterm-126"></a>This method is invoked when an authentication request has been processed by a
realm for the given user. The <tt>success</tt> flag indicates whether the authorization was granted
or denied.</p><pre>public void webInvocation(String user, HttpServletRequest req, String type, boolean success)</pre><p><a name="indexterm-127"></a>This method is invoked when a web container call has been processed by
authorization. The <tt>success</tt> flag indicates whether the authorization was granted or denied. The <tt>req</tt>
object is the standard <tt>HttpServletRequest</tt> object for this request. The <tt>type</tt> string is
one of <tt>hasUserDataPermission</tt> or <tt>hasResourcePermission</tt> (see <a href="http://www.jcp.org/en/jsr/detail?id=115">JSR 115</a>).</p><pre>public void ejbInvocation(String user, String ejb, String method, boolean success)</pre><p>This method is invoked when an EJB container call has been processed by
authorization. The <tt>success</tt> flag indicates whether the authorization was granted or denied. The
<tt>ejb</tt> and <tt>method</tt> strings describe the EJB component and its method that is
being invoked.</p><pre>public void webServiceInvocation(String uri, String endpoint, boolean success)</pre><p>This method is invoked during validation of a web service request in which
the endpoint is a servlet. The <tt>uri</tt> is the URL representation of the
web service endpoint. The <tt>endpoint</tt> is the name of the endpoint representation.
The <tt>success</tt> flag indicates whether the authorization was granted or denied.</p><pre>public void ejbAsWebServiceInvocation(String endpoint, boolean success)</pre><p>This method is invoked during validation of a web service request in which
the endpoint is a stateless session bean. The <tt>endpoint</tt> is the name of
the endpoint representation. The <tt>success</tt> flag indicates whether the authorization was granted or
denied.</p>

<a name="beabx"></a><h3>The <tt>server.policy</tt> File</h3>
<a name="indexterm-128"></a><a name="indexterm-129"></a><p>Each Enterprise Server domain has its own global J2SE policy file, located in
<i>domain-dir</i><tt>/config</tt>. The file is named <tt>server.policy</tt>.</p><p><a name="indexterm-130"></a>The Enterprise Server is a Java EE compliant application server. As such, it
follows the requirements of the Java EE specification, including the presence of the
security manager (the Java component that enforces the policy) and a limited permission set
for Java EE application code.</p><p>This section covers the following topics:</p>
<ul><li><p><a href="#beaby">Default Permissions</a></p></li>
<li><p><a href="#beabz">Changing Permissions for an Application</a></p></li>
<li><p><a href="#gbyah">Enabling and Disabling the Security Manager</a></p></li></ul>


<a name="beaby"></a><h4>Default Permissions</h4>
<a name="indexterm-131"></a><a name="indexterm-132"></a><p>Internal server code is granted all permissions. These are covered by the <tt>AllPermission</tt>
grant blocks to various parts of the server infrastructure code. Do not modify
these entries.</p><p>Application permissions are granted in the default grant block. These permissions apply to
all code not part of the internal server code listed previously. The Enterprise
Server does not distinguish between EJB and web module permissions. All code is granted
the minimal set of web component permissions (which is a superset of the
EJB minimal set). Do not modify these entries.</p><p>A few permissions above the minimal set are also granted in the default
<tt>server.policy</tt> file. These are necessary due to various internal dependencies of the server
implementation. Java EE application developers must not rely on these additional permissions. In some
cases, deleting these permissions might be appropriate. For example, one additional permission is
granted specifically for using connectors. If connectors are not used in a particular
domain, you should remove this permission, because it is not otherwise necessary.</p>

<a name="beabz"></a><h4>Changing Permissions for an Application</h4>
<a name="indexterm-133"></a><a name="indexterm-134"></a><p>The default policy for each domain limits the permissions of Java EE deployed
applications to the minimal set of permissions required for these applications to operate
correctly. Do not add extra permissions to the default set (the grant block
with no codebase, which applies to all code). Instead, add a new grant
block with a codebase specific to the applications requiring the extra permissions, and
only add the minimally necessary permissions in that block. </p><p>If you develop multiple applications that require more than this default set of
permissions, you can add the custom permissions that your applications need. The <tt>com.sun.aas.instanceRoot</tt>
variable refers to the <i>domain-dir</i>. For example:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/-" {
...
}</pre><p>You can add permissions to stub code with the following grant block:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/generated/-" {
...
}</pre><p>In general, you should add extra permissions only to the applications or modules
that require them, not to all applications deployed to a domain. For example:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/MyApp/-" {
...
}</pre><p>For a module:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/MyModule/-" {
...
}</pre>
<hr><p><b>Note - </b>Deployment directories may change between Enterprise Server releases.</p>
<hr>
<p>An alternative way to add permissions to a specific application or module is
to edit the <tt>granted.policy</tt> file for that application or module. The <tt>granted.policy</tt> file is
located in the <i>domain-dir</i><tt>/generated/policy/</tt><i>app-or-module-name</i> directory. In this case, you add permissions to the
default grant block. Do not delete permissions from this file.</p><p>When the application server policy subsystem determines that a permission should not be
granted, it logs a <tt>server.policy</tt> message specifying the permission that was not granted
and the protection domains, with indicated code source and principals that failed the protection
check. For example, here is the first part of a typical message:</p><pre>[#|2005-12-17T16:16:32.671-0200|INFO|sun-appserver-pe9.1|
javax.enterprise.system.core.security|_ThreadID=14;_ThreadName=Thread-31;|
JACC Policy Provider: PolicyWrapper.implies, context(null)- 
permission((java.util.PropertyPermission java.security.manager write)) 
domain that failed(ProtectionDomain
(file:/E:/glassfish/domains/domain1/applications/cejug-clfds/ ... )
...</pre><p>Granting the following permission eliminates the message:</p><pre>grant codeBase "file:${com.sun.aas.instanceRoot}/applications/cejug-clfds/-" {
    permission java.util.PropertyPermission "java.security.manager", "write";
}</pre>
<hr><p><b>Note - </b>Do not add <tt>java.security.AllPermission</tt> to the <tt>server.policy</tt> file for application code. Doing so completely
defeats the purpose of the security manager, yet you still get the performance
overhead associated with it.</p>
<hr>
<p>As noted in the Java EE specification, an application should provide documentation of
the additional permissions it needs. If an application requires extra permissions but does
not document the set it needs, contact the application author for details.</p><p>As a last resort, you can iteratively determine the permission set an application
needs by observing <tt>AccessControlException</tt> occurrences in the server log. </p><p><a name="indexterm-135"></a><a name="indexterm-136"></a>If this is not sufficient, you can add the <tt>-Djava.security.debug=failure</tt> JVM option to the
domain. Use the following <tt>asadmin create-jvm-options</tt> command, then restart the server:</p><pre>asadmin create-jvm-options --user adminuser -Djava.security.debug=failure</pre><p>For more information about the <tt>asadmin create-jvm-options</tt> command, see the <a href="http://docs.sun.com/doc/820-4497"><i>Sun GlassFish Enterprise Server v3 Prelude Reference Manual</i></a>.</p><p>You can use the J2SE standard <tt>policytool</tt> or any text editor to edit
the <tt>server.policy</tt> file. For more information, see <a href="http://java.sun.com/docs/books/tutorial/security1.2/tour2/index.html">http://java.sun.com/docs/books/tutorial/security1.2/tour2/index.html</a>.</p><p>For detailed information about policy file syntax, see <a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html#FileSyntax">http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html#FileSyntax</a>.</p><p>For information about using system properties in the <tt>server.policy</tt> file, see <a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html#PropertyExp">http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html#PropertyExp</a>.
For information about Enterprise Server system properties, see <a href="http://docs.sun.com/doc/820-4507/abhey?a=view">system-property in <i>Sun GlassFish Enterprise Server v3 Prelude Administration Reference</i></a>.</p><p>For detailed information about the permissions you can set in the <tt>server.policy</tt> file,
see <a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/permissions.html">http://java.sun.com/j2se/1.5.0/docs/guide/security/permissions.html</a>.</p><p>The Javadoc for the <tt>Permission</tt> class is at <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/security/Permission.html">http://java.sun.com/j2se/1.5.0/docs/api/java/security/Permission.html</a>.</p>

<a name="gbyah"></a><h4>Enabling and Disabling the Security Manager</h4>
<a name="indexterm-137"></a><p>The security manager is disabled by default.</p><p>In a production environment, you may be able to safely disable the security
manager if all of the following are true:</p>
<ul><li><p>Performance is critical</p></li>
<li><p>Deployment to the production server is carefully controlled</p></li>
<li><p>Only trusted applications are deployed</p></li>
<li><p>Applications don't need policy enforcement</p></li></ul>
<p>Disabling the security manager may improve performance significantly for some types of applications.
To disable the security manager, do one of the following:</p>
<ul><li><p><a name="indexterm-138"></a>To use the Administration Console, open the Security component under the relevant configuration, and uncheck the Security Manager Enabled box. Then restart the server. For details, click the Help button in the Administration Console.</p></li>
<li><p><a name="indexterm-139"></a><a name="indexterm-140"></a>Use the following <tt>asadmin delete-jvm-options</tt> command, then restart the server:</p><pre>asadmin delete-jvm-options --user adminuser -Djava.security.manager</pre><p>To re-enable the security manager, use the corresponding <tt>create-jvm-options</tt> command. For more information about the <tt>create-jvm-options</tt> and <tt>asadmin delete-jvm-options</tt> commands, see the <a href="http://docs.sun.com/doc/820-4497"><i>Sun GlassFish Enterprise Server v3 Prelude Reference Manual</i></a>.</p></li></ul>


<a name="beacm"></a><h3>Programmatic Login</h3>
<p><a name="indexterm-141"></a><a name="indexterm-142"></a><a name="indexterm-143"></a><a name="indexterm-144"></a>Programmatic login allows a deployed Java EE application or module to invoke a
login method. If the login is successful, a <tt>SecurityContext</tt> is established as if the
client had authenticated using any of the conventional Java EE mechanisms. Programmatic login
is supported for servlet and EJB components on the server side, and for
stand-alone or application clients on the client side. Programmatic login is useful for
an application having special needs that cannot be accommodated by any of the
Java EE standard authentication mechanisms.</p>
<hr><p><b>Note - </b>Programmatic login is specific to the Enterprise Server and not portable to other
application servers.</p>
<hr>
<p>This section contains the following topics:</p>
<ul><li><p><a href="#beacn">Programmatic Login Precautions</a></p></li>
<li><p><a href="#beaco">Granting Programmatic Login Permission</a></p></li>
<li><p><a href="#beacp">The <tt>ProgrammaticLogin</tt> Class</a></p></li></ul>


<a name="beacn"></a><h4>Programmatic Login Precautions</h4>
<p>The Enterprise Server is not involved in how the login information (<tt>user</tt>, <tt>password</tt>)
is obtained by the deployed application. Programmatic login places the burden on the application
developer with respect to assuring that the resulting system meets security requirements. If
the application code reads the authentication information across the network, the application determines whether
to trust the user.</p><p>Programmatic login allows the application developer to bypass the application server-supported authentication mechanisms
and feed authentication data directly to the security service. While flexible, this capability should
not be used without some understanding of security issues.</p><p>Since this mechanism bypasses the container-managed authentication process and sequence, the application developer
must be very careful in making sure that authentication is established before accessing any
restricted resources or methods. It is also the application developer&#8217;s responsibility to verify
the status of the login attempt and to alter the behavior of the
application accordingly.</p><p>The programmatic login state does not necessarily persist in sessions or participate in
single sign-on.</p><p>Lazy authentication is not supported for programmatic login. If an access check is
reached and the deployed application has not properly authenticated using the programmatic login
method, access is denied immediately and the application might fail if not coded to
account for this occurrence. One way to account for this occurrence is to
catch the access control or security exception, perform a programmatic login, and repeat
the request.</p>

<a name="beaco"></a><h4>Granting Programmatic Login Permission</h4>
<a name="indexterm-145"></a><p>The <tt>ProgrammaticLoginPermission</tt> permission is required to invoke the programmatic login mechanism for an
application if the security manager is enabled. For information about the security manager, see
<a href="#beabx">The <tt>server.policy</tt> File</a>. This permission is not granted by default to deployed applications because this is
not a standard Java EE mechanism.</p><p><a name="indexterm-146"></a>To grant the required permission to the application, add the following to the
<i>domain-dir</i><tt>/config/server.policy</tt> file:</p><pre>grant codeBase "file:<i>jar-file-path</i>" {
     permission com.sun.appserv.security.ProgrammaticLoginPermission
     "login";
 };</pre><p>The <i>jar-file-path</i> is the path to the application&#8217;s JAR file.</p>

<a name="beacp"></a><h4>The <tt>ProgrammaticLogin</tt> Class</h4>
<p><a name="indexterm-147"></a><a name="indexterm-148"></a>The <tt>com.sun.appserv.security.ProgrammaticLogin</tt> class enables a user to perform login programmatically.</p><p>For Javadoc tool pages relevant to programmatic login, go to <a href="https://glassfish.dev.java.net/nonav/api/v3-prelude/index.html">https://glassfish.dev.java.net/nonav/api/v3-prelude/index.html</a> and click
on the <tt>com.sun.appserv.security</tt> package.</p><p>The <tt>ProgrammaticLogin</tt> class has four <tt>login</tt> methods, two for servlets or JSP
files and two for EJB components.</p><p>The login methods for servlets or JSP files have the following signatures:</p><pre>public java.lang.Boolean login(String user, String password, 
    javax.servlet.http.HttpServletRequest request, 
    javax.servlet.http.HttpServletResponse response)</pre><pre>public java.lang.Boolean login(String user, String password, 
    String realm, javax.servlet.http.HttpServletRequest request, 
    javax.servlet.http.HttpServletResponse response, boolean errors) 
    throws java.lang.Exception</pre><p>The login methods for EJB components have the following signatures:</p><pre>public java.lang.Boolean login(String user, String password)</pre><pre>public java.lang.Boolean login(String user, String password, 
    String realm, boolean errors) throws java.lang.Exception</pre><p>All of these <tt>login</tt> methods accomplish the following:</p>
<ul><li><p>Perform the authentication</p></li>
<li><p>Return <tt>true</tt> if login succeeded, <tt>false</tt> if login failed</p></li></ul>
<p>The login occurs on the <tt>realm</tt> specified unless it is null, in which
case the domain&#8217;s default realm is used. The methods with no <tt>realm</tt> parameter
use the domain&#8217;s default realm.</p><p>If the <tt>errors</tt> flag is set to <tt>true</tt>, any exceptions encountered during the
login are propagated to the caller. If set to <tt>false</tt>, exceptions are thrown.</p><p>On the client side, <tt>realm</tt> and <tt>errors</tt> parameters are ignored and the actual
login does not occur until a resource requiring a login is accessed. A
<tt>java.rmi.AccessException</tt> with <tt>COBRA NO_PERMISSION</tt> occurs if the actual login fails.</p><p>The logout methods for servlets or JSP files have the following signatures:</p><pre>public java.lang.Boolean logout(HttpServletRequest request, 
    HttpServletResponse response)</pre><pre>public java.lang.Boolean logout(HttpServletRequest request, 
    HttpServletResponse response, boolean errors) 
    throws java.lang.Exception</pre><p>The logout methods for EJB components have the following signatures:</p><pre>public java.lang.Boolean logout()</pre><pre>public java.lang.Boolean logout(boolean errors) 
    throws java.lang.Exception</pre><p>All of these <tt>logout</tt> methods return <tt>true</tt> if logout succeeded, <tt>false</tt> if
logout failed.</p><p>If the <tt>errors</tt> flag is set to <tt>true</tt>, any exceptions encountered during the
logout are propagated to the caller. If set to <tt>false</tt>, exceptions are thrown.</p>

<a name="beacq"></a><h3>User Authentication for Single Sign-on</h3>
<a name="indexterm-149"></a><a name="indexterm-150"></a><p>The single sign-on feature of the Enterprise Server allows multiple web applications deployed
to the same virtual server to share the user authentication state. With single
sign-on enabled, users who log in to one web application become implicitly logged into
other web applications on the same virtual server that require the same authentication
information. Otherwise, users would have to log in separately to each web application
whose protected resources they tried to access.</p><p>A sample application using the single sign-on scenario could be a consolidated airline
booking service that searches all airlines and provides links to different airline web
sites. After the user signs on to the consolidated booking service, the user
information can be used by each individual airline site without requiring another sign-on.</p><p>Single sign-on operates according to the following rules:</p>
<ul><li><p>Single sign-on applies to web applications configured for the same realm and virtual server. The realm is defined by the <tt>realm-name</tt> element in the <tt>web.xml</tt> file. For information about virtual servers, see <a href="http://docs.sun.com/doc/820-4495/ablsw?a=view">Chapter 8, Administering the HTTP Service, in <i>Sun GlassFish Enterprise Server v3 Prelude Administration Guide</i></a>.</p></li>
<li><p>As long as users access only unprotected resources in any of the web applications on a virtual server, they are not challenged to authenticate themselves.</p></li>
<li><p>As soon as a user accesses a protected resource in any web application associated with a virtual server, the user is challenged to authenticate himself or herself, using the login method defined for the web application currently being accessed.</p></li>
<li><p>After authentication, the roles associated with this user are used for access control decisions across all associated web applications, without challenging the user to authenticate to each application individually.</p></li>
<li><p>When the user logs out of one web application (for example, by invalidating the corresponding session), the user&#8217;s sessions in all web applications are invalidated. Any subsequent attempt to access a protected resource in any application requires the user to authenticate again.</p></li></ul>
<p>The single sign-on feature utilizes HTTP cookies to transmit a token that associates
each request with the saved user identity, so it can only be used
in client environments that support cookies.</p><p><a name="indexterm-151"></a>To configure single sign-on, set the following properties in the <tt>virtual-server</tt> element of the
<tt>domain.xml</tt> file:</p>
<ul><li><p><tt>sso-enabled</tt> - If <tt>false</tt>, single sign-on is disabled for this virtual server, and users must authenticate separately to every application on the virtual server. The default is <tt>false</tt>.</p></li>
<li><p><tt>sso-max-inactive-seconds</tt> - Specifies the time after which a user&#8217;s single sign-on record becomes eligible for purging if no client activity is received. Since single sign-on applies across several applications on the same virtual server, access to any of the applications keeps the single sign-on record active. The default value is 5 minutes (<tt>300</tt> seconds). Higher values provide longer single sign-on persistence for the users at the expense of more memory use on the server.</p></li>
<li><p><tt>sso-reap-interval-seconds</tt> - Specifies the interval between purges of expired single sign-on records. The default value is <tt>60</tt>.</p></li></ul>
<p>Here is an example configuration with all default values:</p><pre>&#60;virtual-server id="server" ... >
     ...
    &#60;property name="sso-enabled" value="true"/>
     &#60;property name="sso-max-inactive-seconds" value="300"/>
     &#60;property name="sso-reap-interval-seconds" value="60"/>
 &#60;/virtual-server></pre>


<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p8.html">Previous</a></td>
<td></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p10.html">Next</a></td>
</tr>
</table>



</body>
</html>

